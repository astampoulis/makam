%use niceml.
niceml : testsuite. %testsuite niceml.

>> concrete.names_of exprvar (ptuple [cpvar (concrete.name exprvar "a"), cpvar (concrete.name exprvar "b")]) X ?
>> Yes:
>> X := [concrete.name exprvar "a", concrete.name exprvar "b"].

>> syntax.run program_concrete {{ let x = () in x }} X ?
>> Yes:
>> X := concrete (main (clet (tuple (concrete.name exprvar "x") (etuple nil)) (concrete.var (concrete.name exprvar "x")))).

>> syntax.run program_concrete {{ let x = () in match x { (a, b) => a } }} X ?
>> Yes:
>> X :=concrete (main (clet (tuple (concrete.name exprvar "x") (etuple nil)) (match (concrete.var (concrete.name exprvar "x")) (cons (cbranch (ptuple (cons (cpvar (concrete.name exprvar "a")) (cons (cpvar (concrete.name exprvar "b")) nil))) (concrete.var (concrete.name exprvar "a"))) nil)))).

>> (syntax.run program_concrete {{ let x = () in match x { (a, b) => a } }} _X, concrete.resolve _X Y) ?
>> Yes:
>> Y := main (let (etuple nil) (bind "x" (fun anon10331_0 => match anon10331_0 (cons (branch (tuple (ptuple (cons pvar (cons pvar nil))) (bind "a" (fun anon10316_1 => bind "b" (fun anon9147_2 => body anon10316_1))))) nil)))).

>> (isocast {{
 data tree = `leaf of () | `node of tree * int * tree ;
   letrec map = fun f tree =>
     match tree {
       `leaf() => `leaf()
     | `node(l, i, r) => `node(map(f,l), f(i), map(f,r))
     }
   in map
 }} (_X: concrete program), concrete.resolve _X _Y, concrete.resolve _Z _Y, eq_nounif _Z _X) ?
>> Yes.

>> (a:typ -> b:typ -> typeof (ptuple [pvar, pvar]) (product [a, b]) [] #XS) ?
>> Yes:
>> XS := fun a b => [a, b].

>> typechecker {{
 data tree = `leaf of () | `node of tree * int * tree ;
 `leaf()
}} X ?
>> Yes:
>> X := sdata (datadef (bind "tree" (fun anon10972_0 => tuple (cons (product nil) (cons (product (cons anon10972_0 (cons tint (cons anon10972_0 nil)))) nil)) (bind "leaf" (fun anon10316_1 => bind "node" (fun anon10324_2 => body (smain anon10972_0))))))).

>> typechecker {{
 data tree = `leaf of () | `node of tree * int * tree ;
   letrec map = fun f tree =>
     match tree {
       `leaf() => `leaf()
     | `node(l, i, r) => `node(map(f,l), f(i), map(f,r))
     }
   in map
}} Y ?
>> Yes:
>> Y := sdata (datadef (bind "tree" (fun anon54076_0 => tuple (cons (product nil) (cons (product (cons anon54076_0 (cons tint (cons anon54076_0 nil)))) nil)) (bind "leaf" (fun anon43328_1 => bind "node" (fun anon43336_2 => body (smain (arrowmany (cons (arrowmany (cons tint nil) tint) (cons anon54076_0 nil)) anon54076_0)))))))).

>> (typechecker {{
 data tree = `leaf of () | `node of tree * int * tree ;
   letrec map = fun f tree =>
     match tree {
       `leaf() => `leaf()
     | `node(l, i, r) => `node(map(f,l), f(i), map(f,r))
     }
   in map
}} _Y, concrete.resolve (_X: concrete sig) _Y, syntax.pretty sig_concrete _X S) ?
>> Yes:
>> S := {{sig data tree = ` leaf of () | ` node of tree * int * tree ; 
(main) : ( int -> int , tree ) -> tree end }}.

>> (typechecker {{
 data tree = `leaf of () | `node of tree * int * tree ;
   letrec map = fun f tree =>
     match tree {
       `leaf() => `leaf()
     | `node(l, i, r) => `node(map(f,l), f(i), map(f,r))
     }
   in map
}} _Y, isocast _Y S) ?
>> Yes:
>> S := {{sig data tree = ` leaf of () | ` node of tree * int * tree ; 
(main) : ( int -> int , tree ) -> tree end }}.
