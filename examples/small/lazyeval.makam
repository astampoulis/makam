(* An implementation of the standard Launchbury semantics
   for call-by-need evaluation, using an explicit heap. *)

expr : type.
var : type.

lam : (var -> expr) -> expr.

(* Arguments to applications need to be variables *)
app : expr -> var -> expr.

var : var -> expr.

let : bindmany var (list expr * expr) -> expr.

intconst : int -> expr.

binop : (int -> int -> int -> prop) -> expr -> expr -> expr.

(* now let's model heaps. In this semantics, heaps are
   variable binding - expression definition pairs. In Makam,
   we will model them as a number of bindings followed by
   their definitions in the same order.
*)

heap : type -> type.

heap : bindmany var (list expr * A) -> heap A.

index_of : var -> int -> prop.

assumeindex : list var -> prop -> prop.
assumeindex_aux : int -> list var -> prop -> prop.
assumeindex_aux _ [] P when P.
assumeindex_aux N (X :: XS) P when
  plus N 1 N',
  assumeindex_aux N' XS {prop| (index_of X N -> P) |}.

assumeindex L P when assumeindex_aux 0 L P.

heaplist : type -> type.
nil : heaplist t_nil.
cons : heap HD -> heaplist TL -> heaplist (t_cons HD TL).

%extend list.

split : int -> list A -> list A -> list A -> prop.
split 0 Post [] Post.
split N (X :: XS) (X :: Pre) Post :-
  plus 1 N' N,
  split N' XS Pre Post.

bring_to_top : int -> list A -> list A -> prop.
bring_to_top Index XS (X :: XS') :-
  split Index XS XSPre (X :: XSPost),
  append XSPre XSPost XS'.

unbring_to_top : int -> list A -> list A -> prop.
unbring_to_top Index (X :: XS) XS' :-
  split Index XS XSPre XSPost,
  append XSPre (X :: XSPost) XS'.

nth : list A -> int -> A -> prop.
nth L N E :-
  split N L _ (E :: _).

update_nth : list A -> int -> A -> list A -> prop.
update_nth L N E L' :-
  split N L Pre (_ :: Post),
  split N L' Pre (E :: Post).

%end.

%extend heap.

open : heap A -> (list var -> list expr -> A -> prop) -> prop.

open (heap XS_DefsBody) P :-
  bindmany.open XS_DefsBody (pfun XS (Defs, Body) =>
    assumeindex XS (P XS Defs Body)).

(* used as a marker to denote which definitions to keep *)
keep : heap A -> heap A.

pair, pair_ : heap A -> heap B -> heap (A * B) -> prop.
pair A B C :- once(pair_ A B C).
pair_ (heap (body (Defs, Body1))) (heap (body (Defs, Body2)))
      (heap (body (Defs, (Body1, Body2)))).

pair_ (heap (bind Name F)) (heap (bind Name F')) (heap (bind Name F'')) :-
  (x:A -> pair_ (heap (F x)) (heap (F' x)) (heap (F'' x))).

many : [A] heaplist A -> heap (hlist A) -> prop.
many_aux : [Head Tail] heap Head -> heaplist Tail -> heap (hlist Tail) -> prop.

many (Heap :: Heaps) Result :-
  many_aux Heap Heaps Heaps',
  pair Heap Heaps' Heaps'',
  pair Heaps'' Result Heaps''',
  open Heaps''' (pfun XS Defs ((HDBody, TLBody), (HDBody :: TLBody)) => success).

many_aux Heap [] Heap' :-
  pair Heap Heap' Heap'',
  open Heap'' (pfun XS Defs (Unused, []) => success).

many_aux Heap (HDHeap :: TLHeap) HeapAll :-
  pair Heap HDHeap HDHeap',
  many_aux Heap TLHeap TLHeap',
  pair HDHeap' TLHeap' Heap',
  pair Heap' HeapAll Heap'',
  open Heap'' (pfun XS Defs (((Unused1, BodyHD), BodyTL), (BodyHD :: BodyTL)) => success).

openmany : heaplist A -> (list var -> list expr -> hlist A -> prop) -> prop.
openmany Heaps P :- many Heaps Heaps', open Heaps' P.

apply : heap A -> list var -> list expr -> A -> prop.
apply (heap (body (Defs, Body))) [] Defs Body.
apply (heap (bind Name Rest)) (X :: XS) Defs Body :-
  unless (nameofvar X Name) (success),
  apply (heap (Rest X)) XS Defs Body.

collapse : heap (heap A) -> heap A -> prop.
extract : heap A -> heap B -> heap (heap A) -> prop.

collapse (heap AS_BS_Body) ASBS_Body :-
  bindmany.open AS_BS_Body (pfun AS (ADefs, heap BS_Body) =>
    bindmany.open BS_Body (pfun BS (BDefs, Body) => [ASBS ABDefs]
      append AS BS ASBS,
      append ADefs BDefs ABDefs,
      heap.apply ASBS_Body ASBS ABDefs Body)).

extract Heap HeapRef Heap' :-
  heap.open HeapRef (pfun AS Defs Body => length AS N),
  heap.open Heap (pfun ASBS ASBSDefs Body => [AS BS ASDefs BSDefs Heap'']
    list.split N ASBS AS BS,
    list.split N ASBSDefs ASDefs BSDefs,
    heap.apply Heap' AS ASDefs Heap'',
    heap.apply Heap'' BS BSDefs Body).

bring_to_top : int -> heap A -> heap A -> prop.
bring_to_top Index Heap Heap' :-
  heap.open Heap (pfun XS Defs Body => [XS' Defs']
    list.bring_to_top Index XS XS',
    list.bring_to_top Index Defs Defs',
    heap.apply Heap' XS' Defs' Body
  ).

unbring_to_top : int -> heap A -> heap A -> prop.
unbring_to_top Index Heap Heap' :-
  heap.open Heap (pfun XS Defs Body => [XS' Defs']
    list.unbring_to_top Index XS XS',
    list.unbring_to_top Index Defs Defs',
    heap.apply Heap' XS' Defs' Body
  ).

tests : testsuite. %testsuite tests.

>> heap.many [heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], var a))))] X ?
>> Yes:
>> X := heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], [var a])))).

>> heap.many [heap (bind "a" (fun a => body ([var a], var a))), H1, H2] X ?
>> Yes:
>> X := heap (bind "a" (fun a => body (tuple [ (var a) ] [ (var a), #Body1, #Body2 ]))),
>> H1 := heap (bind "a" (fun a => body (tuple [ (var a) ] #Body1))),
>> H2 := heap (bind "a" (fun a => body (tuple [ (var a) ] #Body2))).

>> heap.many [heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], var a)))),
           heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], var b))))] X ?
>> Yes:
>> X := heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], [var a, var b])))).

>> heap.collapse (heap (bind "a" (fun a => body ([var a], heap (bind "b" (fun b => body ([var b], [var b, var a]))))))) X ?
>> Yes:
>> X := heap (bind "a" (fun a => bind "b" (fun b => body (tuple [ (var a), (var b) ] [ (var b), (var a) ])))).

>> heap.extract (heap (bind "a" (fun a => bind "b" (fun b => body (tuple [ (var a), (var b) ] [ (var b), (var a) ]))))) (heap (bind "a" (fun a => body ([app (var a) a], 1)))) X ?
>> Yes:
>> X := heap (bind "a" (fun a => body (tuple [ (var a) ] (heap (bind "b" (fun b => body (tuple [ (var b) ] [ (var b), (var a) ]))))))).

%end.

eval : heap expr -> heap (heap expr) -> prop.

return : heap expr -> heap (heap expr) -> prop.

return Heap Heap' :-
  heap.pair Heap Heap' Heap'',
  heap.open Heap'' (pfun XS Defs (Body, heap (body ([], Body))) => success).

(*

  ———————————————————
  Γ : λx.e ⇓ Γ : λx.e

*)

eval (Heap_Body) Result
    when heap.open Heap_Body (pfun XS Defs (lam X_E) => success) :-
  return Heap_Body Result.

(*

   Γ : e ⇓ Δ : λy.e'   Δ : e'[x/y] ⇓ Θ : z
   ————————————————————————————————————————
              Γ : e x ⇓ Θ : z

*)

eval (Heap0_Body0) (Heap0_Heap12_Body')
  when heap.open Heap0_Body0 (pfun XS Defs (app E X) => success) :-

  heap.openmany [Heap0_Body0, Heap0_Fun] (pfun XS Defs [app E X, Fun] => eq Fun E),

  eval Heap0_Fun Heap0_Heap1_Body1,
  heap.openmany [Heap0_Heap1_Body1, Heap0_Heap1_Body2]
    (pfun XS Defs [Heap1_Body1, Heap1_Body2] => [Unused E X]
    heap.apply Heap0_Body0 XS Unused (app E X),
    heap.openmany [Heap1_Body1, Heap1_Body2]
      (pfun XS' Defs' [lam Y_E', Body2] =>
        eq Body2 (Y_E' X))),

  heap.collapse Heap0_Heap1_Body2 Heap01_Body2,
  eval Heap01_Body2 Heap01_Heap2_Body',
  heap.collapse Heap01_Heap2_Body' Heap012_Body',
  heap.extract Heap012_Body' Heap0_Body0 Heap0_Heap12_Body'.


(*

  —————————————-
  Γ : n ⇓ Γ : n

*)

eval (Heap_Body) Result
    when heap.open Heap_Body (pfun XS Defs (intconst N) => success) :-
  return Heap_Body Result.

(*

   Γ : e1 ⇓ Δ : n1     Δ : e2 ⇓ Θ : n2    OP n1 n2 = n3
   —————————————————————————————————————————————————————
              Γ : binop OP e1 e2 ⇓ Θ : n3

*)

eval (Heap0_Body0) (Heap0_Heap12_Body')
  when heap.open Heap0_Body0 (pfun XS Defs (binop OP E1 E2) => success) :-

  heap.openmany [Heap0_Body0, Heap0_E1, Heap0_E2] (pfun XS Defs [binop OP E1 E2, E1, E2] => eq OP OP_),

  eval Heap0_E1 Heap0_Heap1_Eval1,

  heap.openmany [Heap0_Heap1_Eval1, Heap0_Heap1_Body2]
    (pfun XS Defs [Heap1_Eval1, Heap1_Body2] => [Unused E2]
    heap.apply Heap0_E2 XS Unused E2,
    heap.openmany [Heap1_Eval1, Heap1_Body2]
      (pfun XS' Defs' [intconst N1, Body2] =>
        eq N1 N1_, eq Body2 E2)),

  heap.collapse Heap0_Heap1_Body2 Heap01_Body2,
  eval Heap01_Body2 Heap01_Heap2_Eval2,
  heap.collapse Heap01_Heap2_Eval2 Heap012_Eval2,

  heap.openmany [Heap012_Eval2, Heap012_Result] (pfun XS012 Defs012 [intconst N2, intconst N3] =>
    OP_ N1_ N2 N3
  ),

  heap.extract Heap012_Result Heap0_Body0 Heap0_Heap12_Body'.

(*
           Γ : e ⇓ Δ : z
  —————————————-—————————————————————
  (Γ, x |-> e) : x ⇓ (Δ, x |-> z) : z

  here we differ in that we keep the binding for x alive in the premise

*)

eval (Heap0_Body0) (Heap0_Heap1_Body')
  when heap.open Heap0_Body0 (pfun XS Defs (var X) => success) :-

  heap.openmany [Heap0_Body0, Heap0_E] (pfun XS Defs [var X, E] =>
    index_of X N,
    list.nth Defs N E),

  eval Heap0_E Heap0Upd_Heap1_Eval,
  heap.collapse Heap0Upd_Heap1_Eval Heap0Upd1_Eval,
  heap.open Heap0Upd1_Eval (pfun XS Defs Eval => [Defs']
    list.update_nth Defs N Eval Defs',
    heap.apply Heap0UpdUpd1_Eval XS Defs' Eval),

  heap.extract Heap0UpdUpd1_Eval Heap0_Body0 Heap0_Heap1_Body'.

(*
   Γ, x1 |-> e1 ... xn |-> en : e ⇓ Δ : z
  —————————————-—————————————————————------
  Γ : let x1 = e1 ... xn = en in e ⇓ Δ : z

*)

eval (Heap0_Body0) (Heap0_Heap12_Body')
  when heap.open Heap0_Body0 (pfun XS Defs (let YS_Body) => success) :-

  heap.open Heap0_Body0 (pfun XS XSDefs (let YS_E) =>
    bindmany.open YS_E (pfun YS (YSDefs, E) => [XSYS XSYSDefs]
      append XS YS XSYS,
      append XSDefs YSDefs XSYSDefs,
      heap.apply Heap01_E XSYS XSYSDefs E)),

  eval Heap01_E Heap01_Heap2_Res,
  heap.collapse Heap01_Heap2_Res Heap012_Res,
  heap.extract Heap012_Res Heap0_Body0 Heap0_Heap12_Body'.

maintests : testsuite. %testsuite maintests.

>> eval (heap (body ([], binop plus (intconst 10) (intconst 5)))) X ?
>> Yes:
>> X := heap (body (tuple [  ] (heap (body (tuple [  ] (intconst 15)))))).

>> eval (heap (bind "x" (fun x => (body ([intconst 10], var x))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 10) ] (heap (body (tuple [  ] (intconst 10))))))).

>> eval (heap (bind "x" (fun x => (body ([binop plus (intconst 10) (intconst 5)], var x))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 15) ] (heap (body (tuple [  ] (intconst 15))))))).

>> eval (heap (bind "x" (fun x => (body ([intconst 10], binop plus (intconst 10) (var x) ))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 10) ] (heap (body (tuple [  ] (intconst 20))))))).

>> eval (heap (bind "x" (fun x => (body ([binop plus (intconst 10) (intconst 5)], binop plus (intconst 10) (var x) ))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 15) ] (heap (body (tuple [  ] (intconst 25))))))).

>> eval (heap (bind "x" (fun x => (body ([binop plus (intconst 10) (intconst 5)], binop plus (var x) (var x) ))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 15) ] (heap (body (tuple [  ] (intconst 30))))))).

>> eval (heap (body ([], let (bind "u" (fun u => bind "v" (fun v => body ([binop plus (intconst 2) (intconst 3), binop plus (var u) (intconst 1)], binop plus (var v) (var v)))))))) X ?
>> Yes:
>> X := heap (body (tuple [  ] (heap (bind "u" (fun u => bind "v" (fun v => body (tuple [ (intconst 5), (intconst 6) ] (intconst 12)))))))).
