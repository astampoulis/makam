(* An implementation of the standard Launchbury semantics
   for call-by-need evaluation, using an explicit heap. *)

expr : type.
var : type.

lam : (var -> expr) -> expr.

(* Arguments to applications need to be variables *)
app : expr -> var -> expr.

var : var -> expr.

let : bindmany var (list expr * expr) -> expr.

intconst : int -> expr.

binop : (int -> int -> int -> prop) -> expr -> expr -> expr.

(* now let's model heaps. In this semantics, heaps are
   variable binding - expression definition pairs. In Makam,
   we will model them as a number of bindings followed by
   their definitions in the same order.
*)

heap : type -> type.

heap : bindmany var (list expr * A) -> heap A.

index_of : var -> int -> prop.

assumeindex : list var -> prop -> prop.
assumeindex_aux : int -> list var -> prop -> prop.
assumeindex_aux _ [] P when P.
assumeindex_aux N (X :: XS) P when
  plus N 1 N',
  assumeindex_aux N' XS {prop| (index_of X N -> P) |}.

assumeindex L P when assumeindex_aux 0 L P.

heaplist : type -> type.
nil : heaplist t_nil.
cons : heap HD -> heaplist TL -> heaplist (t_cons HD TL).

%extend list.

split : int -> list A -> list A -> list A -> prop.
split 0 Post [] Post.
split N (X :: XS) (X :: Pre) Post :-
  plus 1 N' N,
  split N' XS Pre Post.

nth : list A -> int -> A -> prop.
nth L N E :-
  split N L _ (E :: _).

update_nth : list A -> int -> A -> list A -> prop.
update_nth L N E L' :-
  split N L Pre (_ :: Post),
  split N L' Pre (E :: Post).

%end.

%extend heap.

open : heap A -> (list var -> list expr -> A -> prop) -> prop.

open (heap XS_DefsBody) P :-
  bindmany.open XS_DefsBody (pfun XS (Defs, Body) =>
    assumeindex XS (P XS Defs Body)).

(* used as a marker to denote which definitions to keep *)
keep : heap A -> heap A.

pair, pair_ : heap A -> heap B -> heap (A * B) -> prop.
pair A B C :- once(pair_ A B C).
pair_ (heap (body (Defs, Body1))) (heap (body (Defs, Body2)))
      (heap (body (Defs, (Body1, Body2)))).

pair_ (heap (bind Name F)) (heap (bind Name F')) (heap (bind Name F'')) :-
  (x:A -> pair_ (heap (F x)) (heap (F' x)) (heap (F'' x))).

many : [A] heaplist A -> heap (hlist A) -> prop.
many_aux : [Head Tail] heap Head -> heaplist Tail -> heap (hlist Tail) -> prop.

many (Heap :: Heaps) Result :-
  many_aux Heap Heaps Heaps',
  pair Heap Heaps' Heaps'',
  pair Heaps'' Result Heaps''',
  open Heaps''' (pfun XS Defs ((HDBody, TLBody), (HDBody :: TLBody)) => success).

many_aux Heap [] Heap' :-
  pair Heap Heap' Heap'',
  open Heap'' (pfun XS Defs (Unused, []) => success).

many_aux Heap (HDHeap :: TLHeap) HeapAll :-
  pair Heap HDHeap HDHeap',
  many_aux Heap TLHeap TLHeap',
  pair HDHeap' TLHeap' Heap',
  pair Heap' HeapAll Heap'',
  open Heap'' (pfun XS Defs (((Unused1, BodyHD), BodyTL), (BodyHD :: BodyTL)) => success).

openmany : heaplist A -> (list var -> list expr -> hlist A -> prop) -> prop.
openmany Heaps P :- many Heaps Heaps', open Heaps' P.

apply : heap A -> list var -> list expr -> A -> prop.
apply (heap (body (Defs, Body))) [] Defs Body.
apply (heap (bind Name Rest)) (X :: XS) Defs Body :-
  unless (nameofvar X Name) (success),
  apply (heap (Rest X)) XS Defs Body.

apply_needed : heap A -> list var -> A -> prop.
apply_needed (heap (body (_, Body))) _ Body.
apply_needed (heap (bind Name Rest)) (X :: XS) Body :-
  unless (nameofvar X Name) (success),
  apply_needed (heap (Rest X)) XS Body.

collapse : heap (heap A) -> heap A -> prop.
extract : heap A -> heap B -> heap (heap A) -> prop.

collapse (heap AS_BS_Body) ASBS_Body :-
  bindmany.open AS_BS_Body (pfun AS (ADefs, heap BS_Body) =>
    bindmany.open BS_Body (pfun BS (BDefs, Body) => [ASBS ABDefs]
      append AS BS ASBS,
      append ADefs BDefs ABDefs,
      heap.apply ASBS_Body ASBS ABDefs Body)).

extract Heap HeapRef Heap' :-
  heap.open HeapRef (pfun AS Defs Body => length AS N),
  heap.open Heap (pfun ASBS ASBSDefs Body => [AS BS ASDefs BSDefs Heap'']
    list.split N ASBS AS BS,
    list.split N ASBSDefs ASDefs BSDefs,
    heap.apply Heap' AS ASDefs Heap'',
    heap.apply Heap'' BS BSDefs Body).

tests : testsuite. %testsuite tests.

>> heap.many [heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], var a))))] X ?
>> Yes:
>> X := heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], [var a])))).

>> heap.many [heap (bind "a" (fun a => body ([var a], var a))), H1, H2] X ?
>> Yes:
>> X := heap (bind "a" (fun a => body (tuple [ (var a) ] [ (var a), #Body1, #Body2 ]))),
>> H1 := heap (bind "a" (fun a => body (tuple [ (var a) ] #Body1))),
>> H2 := heap (bind "a" (fun a => body (tuple [ (var a) ] #Body2))).

>> heap.many [heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], var a)))),
           heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], var b))))] X ?
>> Yes:
>> X := heap (bind "a" (fun a => bind "b" (fun b => body ([var a, var b], [var a, var b])))).

>> heap.collapse (heap (bind "a" (fun a => body ([var a], heap (bind "b" (fun b => body ([var b], [var b, var a]))))))) X ?
>> Yes:
>> X := heap (bind "a" (fun a => bind "b" (fun b => body (tuple [ (var a), (var b) ] [ (var b), (var a) ])))).

>> heap.extract (heap (bind "a" (fun a => bind "b" (fun b => body (tuple [ (var a), (var b) ] [ (var b), (var a) ]))))) (heap (bind "a" (fun a => body ([app (var a) a], 1)))) X ?
>> Yes:
>> X := heap (bind "a" (fun a => body (tuple [ (var a) ] (heap (bind "b" (fun b => body (tuple [ (var b) ] [ (var b), (var a) ]))))))).

%end.

eval : heap expr -> heap expr -> prop.

(*

  ———————————————————
  Γ : λx.e ⇓ Γ : λx.e

*)

eval (Heap_Body) Result
    when heap.open Heap_Body (pfun XS Defs (lam X_E) => success) :-
  eq Heap_Body Result.

(*

   Γ : e ⇓ Δ : λy.e'   Δ : e'[x/y] ⇓ Θ : z
   ————————————————————————————————————————
              Γ : e x ⇓ Θ : z

*)

eval (Heap0_Body0) (Heap2_Body2)
  when heap.open Heap0_Body0 (pfun XS Defs (app E X) => success) :-

  heap.open Heap0_Body0 (pfun XS Defs (app E X) =>
    heap.apply Heap0_Fun XS Defs E),
  eval Heap0_Fun Heap1_Body1,

  heap.open Heap1_Body1 (pfun XS Defs (lam Y_E') => [E X]
    heap.apply_needed Heap0_Body0 XS (app E X),
    heap.apply Heap1_Body2 XS Defs (Y_E' X)),
  eval Heap1_Body2 Heap2_Body2.


(*

  —————————————-
  Γ : n ⇓ Γ : n

*)

eval (Heap_Body) Result
    when heap.open Heap_Body (pfun XS Defs (intconst N) => success) :-
  eq Result Heap_Body.

(*

   Γ : e1 ⇓ Δ : n1     Δ : e2 ⇓ Θ : n2    OP n1 n2 = n3
   —————————————————————————————————————————————————————
              Γ : binop OP e1 e2 ⇓ Θ : n3

*)

eval (Heap0_Body0) (Heap2_Result)
  when heap.open Heap0_Body0 (pfun XS Defs (binop OP E1 E2) => success) :-

  heap.open Heap0_Body0 (pfun XS Defs (binop OP E1 E2) =>
    eq OP_ OP,
    heap.apply Heap0_E1 XS Defs E1),
  eval Heap0_E1 Heap1_V1,

  heap.open Heap1_V1 (pfun XS Defs (intconst N1) => [OP E1 E2]
    eq N1 N1_,
    heap.apply_needed Heap0_Body0 XS (binop OP E1 E2),
    heap.apply Heap1_E2 XS Defs E2),
  eval Heap1_E2 Heap2_V2,

  heap.open Heap2_V2 (pfun XS Defs (intconst N2) =>
    eq N2 N2_),
  
  OP_ N1_ N2_ N3,

  heap.open Heap2_V2 (pfun XS Defs V2 =>
    heap.apply Heap2_Result XS Defs (intconst N3)).

(*
           Γ : e ⇓ Δ : z
  —————————————-—————————————————————
  (Γ, x |-> e) : x ⇓ (Δ, x |-> z) : z

  here we differ in that we keep the binding for x alive in the premise

*)

eval (Heap0_Body0) (Heap2_Val)
  when heap.open Heap0_Body0 (pfun XS Defs (var X) => success) :-

  heap.open Heap0_Body0 (pfun XS Defs (var X) => [E]
    index_of X N,
    list.nth Defs N E,
    heap.apply Heap0_E XS Defs E),

  eval Heap0_E Heap1_Val,
  heap.open Heap1_Val (pfun XS Defs Val => [Defs']
    list.update_nth Defs N Val Defs',
    heap.apply Heap2_Val XS Defs' Val).

(*
   Γ, x1 |-> e1 ... xn |-> en : e ⇓ Δ : z
  —————————————-—————————————————————------
  Γ : let x1 = e1 ... xn = en in e ⇓ Δ : z

*)

eval (Heap0_Body0) (Heap2_V)
  when heap.open Heap0_Body0 (pfun XS Defs (let YS_Body) => success) :-

  heap.open Heap0_Body0 (pfun XS XSDefs (let YS_E) =>
    bindmany.open YS_E (pfun YS (YSDefs, E) => [XSYS XSYSDefs]
      append XS YS XSYS,
      append XSDefs YSDefs XSYSDefs,
      heap.apply Heap1_E XSYS XSYSDefs E)),

  eval Heap1_E Heap2_V.

maintests : testsuite. %testsuite maintests.

>> eval (heap (body ([], binop plus (intconst 10) (intconst 5)))) X ?
>> Yes:
>> X := heap (body (tuple [  ] (intconst 15))).

>> eval (heap (bind "x" (fun x => (body ([intconst 10], var x))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 10) ] (intconst 10)))).

>> eval (heap (bind "x" (fun x => (body ([binop plus (intconst 10) (intconst 5)], var x))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 15) ] (intconst 15)))).

>> eval (heap (bind "x" (fun x => (body ([intconst 10], binop plus (intconst 10) (var x) ))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 10) ] (intconst 20)))).

>> eval (heap (bind "x" (fun x => (body ([binop plus (intconst 10) (intconst 5)], binop plus (intconst 10) (var x) ))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 15) ] (intconst 25)))).

>> eval (heap (bind "x" (fun x => (body ([binop plus (intconst 10) (intconst 5)], binop plus (var x) (var x) ))))) X ?
>> Yes:
>> X := heap (bind "x" (fun x => body (tuple [ (intconst 15) ] (intconst 30)))).

>> eval (heap (body ([], let (bind "u" (fun u => bind "v" (fun v => body ([binop plus (intconst 2) (intconst 3), binop plus (var u) (intconst 1)], binop plus (var v) (var v)))))))) X ?
>> Yes:
>> X := heap (bind "u" (fun u => bind "v" (fun v => body (tuple [ (intconst 5), (intconst 6) ] (intconst 12))))).
