(*
*)

%use "03-dependent-binding".

(*

Let us now proceed to encode more features of a programming language like ML using the
techniques we have seen so far.

First, let's add polymorphism, therefore extending our simply typed lambda calculus to
System F. We will only consider the explicit polymorphism case for the time being, and
explore type inference later.

We need a type for quantification over types, as well as term-level constructs for
functions over types and instantiating a polymorphic function with a specific type.

*)

forall : (typ -> typ) -> typ.
lamt : (typ -> term) -> term.
appt : term -> typ -> term.

(*

The typing rules are similarly straightforward.

*)

typeof (lamt E) (forall T) :-
  (a:typ -> typeof (E a) (T a)).

typeof (appt E T) (TF T) :-
  typeof E (forall TF).

(*

One thing to note is that in a pen-and-paper version we would need to define a new
context that keeps track of type variables that are in scope (typically named
$\Delta$), and an auxiliary judgement of the form $\Delta \vdash \tau \text{wf}$ that
checks that all type variables used in $\tau$ are in scope. Here we get type
well-formedness for free. Furthermore, if we had to keep track of further information
about type variables (e.g. their kind), we could have added an assumption of the form
`kindof a K ->`. Since the local assumption context can carry rules for any predicate,
no extra declaration or change to the existing rules would be needed, as would be
required in the pen-and-paper version in order to incorporate the new $\Delta$
context.

With these additions, we can give a polymorphic type to the identity function:

*)

typeof (lamt (fun a => lam a (fun x => x))) T ?

(*

Moving on towards a more ML-like language, we would like to add the option to declare
algebraic datatypes. This requires us to first introduce a notion of top-level
programs, composed of a series of declarations of types and terms, as well as 
a predicate to check that a program is well-formed:

*)

program : type.
wfprogram : program -> prop.

(*

Let us add `let` definitions as a first example of a program component. These introduce
a term variable that can be used in the rest of the program:

*)

let : term -> (term -> program) -> program.

wfprogram (let E P) :-
  typeof E T,
  (x:term -> typeof x T -> wfprogram (P x)).

(*

We also need a "last" component for the program -- typically this takes the form of
a main expression:

*)

main : term -> program.

wfprogram (main E) :-
  typeof E _.

(*

Let us now proceed to algebraic datatypes. Datatypes have a name, a number of type
parameters, and a list of constructors; constructors themselves have a name and a list
of arguments:

*)

typeconstructor : type -> type.
constructor : type.

constructor_declaration : type -> type.
cdnil : constructor_declaration unit.
cdcons : list typ -> constructor_declaration T -> constructor_declaration (constructor * T).

datatype_declaration :
  (typeconstructor T -> dbind typ T (constructor_declaration C)) ->
  (typeconstructor T -> dbind constructor C program) ->
  program.

(*

Adding the necessary predicates:

*)

argumentsof : constructor -> typeconstructor T -> dbind typ T (list typ) -> prop.

open_constructors : [T C]
  typeconstructor T -> subst typ T -> constructor_declaration C -> (subst constructor C -> prop) -> prop.
open_constructors _ _ cdnil P :- P [].
open_constructors TC TVars (cdcons ConstructorType CS) P :-
  applymany PolyC TVars ConstructorType,
  (c:constructor ->
   argumentsof c TC PolyC -> open_constructors TC Subst CS (pfun cs => P (c :: cs))).

wfprogram (datatype_declaration Constructors Rest) :-
  (dt:(typeconstructor T) ->
    openmany (Constructors dt) (pfun tvars constructor_decls =>
      open_constructors dt tvars constructor_decls (pfun constructors => ([Program']
        applymany (Rest dt) constructors Program',
        wfprogram Program')))).

(*

Let's add term- and type-level formers:

*)

tc : typeconstructor T -> subst typ T -> typ.
c : constructor -> subst typ T -> list term -> term.

typeof (c Constructor TypArgs Args) (tc TC TypArgs) :-
  argumentsof Constructor TC PolyC,
  applymany PolyC TypArgs Typs,
  map typeof Args Typs.

(*
*)
