term : type.
typ  : type.

lam : typ -> (term -> term) -> term .
app : term -> term -> term .
eunit : term .

arrow : typ -> typ -> typ .
tunit : typ .

bf : type.
done : bf.

typeof_aux : list bf -> term -> typ -> prop.
typeof_rec : list bf -> term -> typ -> prop .
typeof_var : term -> typ -> prop.

typeof_aux BF (lam T1 E') (arrow T1 T2) :-
  (x:term -> typeof_var x T1 -> typeof_rec BF (E' x) T2).

typeof_aux BF (app E1 E2) T' :-
  typeof_rec BF E1 (arrow T T'), typeof_rec BF E2 T.

typeof_aux BF X T when typeof_var X T.

typeof_aux BF eunit tunit.

typeof_rec (BF :: Rest) E T when refl.isunif BF :-
  guard BF (typeof_aux Rest E T).

typeof_leastfrom : int -> int -> term -> typ -> prop.
bf_force : bf -> list bf -> prop.
bf_limit : int -> prop.

bf_limit 4.
generate : int -> list bf -> prop.
generate 0 [BF].
generate N (BF :: Rest) when lessthan 0 N true :- plus N' 1 N, generate N' Rest.

typeof_leastfrom N Nres E T when bf_limit Nlimit, lessthan N Nlimit true :-
  generate N Rest,
  if (withall(typeof_rec (BF :: Rest) E T) (bf_force BF Rest)) then
    (eq Nres N)
  else
    (plus N 1 N', typeof_leastfrom N' Nres E T).

bf_force BF (BFnew :: Rest) :-
  if (withall (eq BF done) (not(refl.open_constraints BFnew))) then
    success
  else
    (withall (eq BF done) (bf_force BFnew Rest)).

typeof : term -> typ -> prop.
typeof E T :- typeof_leastfrom 0 N E T.

%constraints+.

bool : typ.
f : term.

typeof_aux BF f (arrow tunit (arrow tunit bool)).



tlam : (typ -> term) -> term.
tapp : term -> typ -> term.
pi : (typ -> typ) -> typ.

typeof_aux BF (tlam E) (pi F) :-
  (a:typ -> typeof_rec BF (E a) (F a)).

typeof_aux BF (tapp E T) T' :-
  typeof_rec BF E (pi F),
  eq (F T) T'.


breadthfirst : testsuite. %testsuite breadthfirst.

>> typeof (lam T1 (fun x => eunit)) T ?
>> Yes:
>> T1 := T1,
>> T := arrow T1 tunit.

>> typeof E tunit ?
>> Yes:
>> E := eunit.

>> typeof E (arrow bool tunit) ?
>> Yes:
>> E := lam bool (fun x => eunit).

>> typeof E bool ?
>> Yes:
>> E := app (app f eunit) eunit.


%extend TODO.

foo : typ.
>> typeof E (arrow foo foo) ?
>> Yes:
>> E := lam foo (fun x => x).

>> typeof I (pi (fun a => arrow a a)) ?
>> Yes:
>> I := tlam (fun a => lam a (fun x => x)).

>> typeof K (pi (fun a => pi (fun b => arrow a (arrow b a)))) ?
>> Yes:
>> K := tlam (fun a => tlam (fun b => lam a (fun x => lam b (fun y => x)))).

>> typeof S (pi (fun a => pi (fun b => pi (fun c => arrow (arrow a (arrow b c)) (arrow (arrow a b) (arrow a c)))))) ?
>> Yes:
>> S := (tlam (fun a => tlam (fun b => tlam (fun c => lam (arrow a (arrow b c)) (fun f =>
        lam (arrow a b) (fun get_a_to_b =>
        lam a (fun get_a =>
        app (app f get_a) (app get_a_to_b get_a)))))))).

%end.