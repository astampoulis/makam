(* TODO: namespace everything below peg? *)

peg : type -> type.

bind : peg A -> (A -> peg B) -> peg B.
seq : peg A -> peg B -> peg B.
action : B -> peg B.
choices : list (peg A) -> peg A.

anychar : peg string.
charclass : string -> peg string.
exact : string -> peg string.
neg : peg A -> peg unit.
lookahead : peg A -> peg unit.
empty : peg unit.
void : peg A.
many : peg A -> peg (list A).

(* js-only peg expressions: *)
eval : expansion -> peg A. (* evaluate in host language. needs to return a string of a term of type A *)

builtin : [A] peg A -> prop. (* used to tell if something is one of the builtins or a peg defined in terms of those *)
js_builtin : [A] peg A -> prop. (* used to tell if something is one of the builtins supposed to be used only through js generation, with `parse_opt` *)

builtin (bind _ _).
builtin (seq _ _).
builtin (action _).
builtin (choices _).
builtin anychar.
builtin (charclass _).
builtin (exact _).
builtin (neg _).
builtin (lookahead _).
builtin (empty).
builtin (void).
builtin (many _).

builtin (eval _). js_builtin (eval _).

parse : [A]peg A -> list string -> option (A * list string) -> prop.


parse (bind PegA PegB) S Res :-
  if (parse PegA S (some (A, S'))) then
     parse (PegB A) S' Res
  else
     eq Res none.

parse (seq PegA PegB) S Res :-
  if (parse PegA S (some (_, S'))) then
     parse PegB S' Res
  else
     eq Res none.

parse (action B) S (some (B, S)).

parse (choices []) S none.

parse (choices (HD :: TL)) S Res :-
  if (parse HD S (some R)) then
    eq Res (some R)
  else
    parse (choices TL) S Res.


parse (anychar) [] none.

parse (anychar) (HD :: TL) (some (HD, TL)).

parse (charclass S) (HD :: TL) Res :-
  if (string.contains S HD) then
    eq Res (some (HD, TL))
  else
    eq Res none.

parse (exact S) Input Res :-
  string.explode S List,
  if (append List Rest Input) then
    eq Res (some (S, Rest))
  else
    eq Res none.

parse (neg P) S Res :-
  if (parse P S (some _)) then
    eq Res none
  else
    eq Res (some (unit, S)).

parse (lookahead P) S Res :-
  if (parse P S (some _)) then
    eq Res (some (unit, S))
  else
    eq Res none.

parse (empty) S (some (unit, S)).

parse (void) S none.

parse (many P) S Res :-
  if (parse P S (some (HD, S'))) then
    (eq Res (some (HD :: TL, S'')),
     parse (many P) S' (some (TL, S'')))
  else (eq Res (some ([], S))).

(* js-specific parsers *)
parse X _ _
  when js_builtin X,
       locget X Loc, tostring Loc LocS,
       refl.headargs X Head _, refl.headname Head HeadS,
       print_string `\n-- At ${LocS}, using parse with ${HeadS}, which is a PEG primitive only allowed when using parse_opt.\n`,
       failure.

rule : [A] peg A -> peg A -> prop.

extern_def : [A] peg A -> string -> prop.

get_peg_definition : [A] peg A -> peg A -> prop.
get_external_peg_definition : [A] peg A -> string -> prop.

get_peg_definition P Res when not(builtin P) :-
  refl.rules_get_applicable (rule P _) Rules,
  (*
  if (eq Rules []) then
    (locget P Loc, tostring Loc LocS,
       print_string `\n-- Warning: no PEG definition rules for PEG expression used at ${LocS}\n`,
       failure)
  else
    success,
  *)
  map (pfun def res => [Def Loc LocS Guard]
    if ((eq def (clause (rule P Def) success);
         (eq def (whenclause (rule P Def) Guard success), Guard))) then
      eq res Def
    else
      (locget def Loc, tostring Loc LocS,
       print_string `\n-- Error at PEG definition rule at ${LocS}\n`,
       failure))
  Rules Defs,
  eq Res (choices Defs).

get_external_peg_definition P Res when not(builtin P) :-
  refl.rules_get_applicable (extern_def P _) Rules,
  if (eq Rules [Rule]) then
    success
  else
    (locget P Loc, tostring Loc LocS,
       print_string `\n-- Error: zero or multiple PEG definition rules for external PEG parser used at ${LocS}\n`,
       failure),
  if ((eq Rule (clause (extern_def P Code) success);
      (eq Rule (whenclause (extern_def P Code) Guard success), Guard))) then
    eq Res Code
  else
    (locget Rule Loc, tostring Loc LocS,
     print_string `\n-- Error at external PEG definition rule at ${LocS}\n`,
     failure).

parse P S Res when not(builtin P) :-
  get_peg_definition P P',
  parse P' S Res.

parse : [A] peg A -> string -> (A * string) -> prop.

parse PegA S (A, S') :- string.explode S CharList, parse PegA CharList (some (A, Rest)), string.explode S' Rest.
