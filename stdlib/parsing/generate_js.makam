(* we assume an `input` variable holding the input,
             an `offset` (mutable) variable holding the current index within the input,
             the `parsers` dictionary of parsing functions for all the user-defined peg used.
   the result of a parsing expression is:
   - an expression holding the value part of the result
   - mutation of the offset variable to advance what we're looking at
   - a new dictionary with any extra needed parsers *)

%extend peg.

gen_parse_js : [A]peg A -> map string string (* input parser dictionary *) ->
                           map string string (* output parser dictionary *) ->
                           string (* result expression *) -> prop.

quote_string_js : string -> string -> prop.

quote_string_js S Res :- tostring S Res.

gen_parse_js anychar Dict Dict Result :-
  expansion.str
  `(offset < input.length
   ? JSON.stringify(input[offset++])
   : null)`
  Result.

gen_parse_js (charclass S) Dict Dict Result :-
  quote_string_js S S_js,
  expansion.str
  `((offset < input.length && ${S_js}.includes(input[offset]))
    ? JSON.stringify(input[offset++])
    : null)`
  Result.

gen_parse_js (exact S) Dict Dict Result :-
  quote_string_js S S_js,
  expansion.str
  `(input.startsWith(${S_js}, offset)
     ? (offset += ${S_js}.length, JSON.stringify(${S_js}))
     : null)`
  Result.

gen_parse_js (neg P) Dict Dict' Result :-
  gen_parse_js P Dict Dict' Code,
  expansion.str
  `(function () { const temp = offset; {
     let offset = temp;
     return (${Code} === null ? "unit" : null);
  }})()`
  Result.

gen_parse_js (lookahead P) Dict Dict' Result :-
  gen_parse_js P Dict Dict' Code,
  expansion.str
  `(function () { const temp = offset; {
     let offset = temp;
     return (${Code} === null ? null : "unit");
  }})()`
  Result.

gen_parse_js empty Dict Dict Result :-
  expansion.str `"unit"` Result.

gen_parse_js void Dict Dict "null".

(* now on to the more difficult ones *)

quote_parse_res_js : [A]A -> string -> prop.

gen_parse_js (bind (P : peg A) Name (F : A -> peg B)) Dict Dict'' Result :-
  gen_parse_js P Dict Dict' Code,
  (a:A -> quote_parse_res_js a Name ->
   gen_parse_js (F a) Dict' Dict'' Code'),
  expansion.str
  `(function() {
     const ${Name} = ${Code};
     return (${Name} === null ? null : ${Code'});
   })()`
  Result.

gen_parse_js (seq A B) Dict Dict'' Result :-
  gen_parse_js A Dict Dict' CodeA,
  gen_parse_js B Dict' Dict'' CodeB,
  expansion.str
  `(${CodeA} === null ? null : ${CodeB})`
  Result.

gen_parse_js (choices []) Dict Dict "null".

gen_parse_js (choices (HD :: TL)) Dict Dict'' Result :-
  gen_parse_js HD Dict Dict' CodeHD,
  gen_parse_js (choices TL) Dict' Dict'' CodeTL,
  expansion.str
  `(function () {
     const result = ${CodeHD};
     if (result !== null) return result;
     else return ${CodeTL};
   })()`
  Result.

quote_term_js : [A]reified A -> string -> prop.

quote_terms_js : [A B]reified_args A B -> string -> prop.

quote_terms_js X Result
  when refl.isunif X, locget X X_Loc, tostring X_Loc LocS, print_string `At ${LocS}, uninstantiated reified arguments.\n`.

quote_terms_js [] "".
quote_terms_js (Head :: Tail) Result :-
  quote_term_js Head HeadS,
  quote_terms_js Tail TailS,
  expansion.str ` ${HeadS}${TailS}` Result.

quote_term_js (reified.term Head Args) Result :-
  refl.headname Head HeadS,
  quote_terms_js Args ArgsS,
  expansion.str
  `(${HeadS}${ArgsS})`
  Result.

quote_term_js (reified.const (S : string)) S_js :-
  quote_string_js S S_js.

quote_term_js (reified.const (I : int)) I_js :-
  tostring I I_js.

(* here we need to antiquote the result of `P` *)
quote_term_js (reified.nvar P []) Result :-
  quote_parse_res_js P PRes,
  expansion.str `(\${${PRes}})` Result.

quote_var_js : [A]A -> string -> prop.
latest_quote_var_js : int -> prop.

latest_quote_var_js 0.

quote_term_js (reified.bvar X Args) Result :-
  quote_var_js X Var,
  quote_terms_js Args ArgsS,
  expansion.str `(${Var}${ArgsS})` Result.

quote_term_js (reified.lambda (F : A -> B)) Result :-
  once(latest_quote_var_js I),
  tostring I VarI,
  expansion.str `x_${VarI}` Var,
  plus I 1 I',
  (x:A -> quote_var_js x Var -> latest_quote_var_js I' -> quote_term_js (F x) Body),
  expansion.str `(fun ${Var} => ${Body})` Result.

(* TODO: decide if and how unification variables will be supported. *)

gen_parse_js (action X) Dict Dict Result :-
  reify X X_Reified,
  quote_term_js X_Reified X_js,
  expansion.str `\`${X_js}\`` Result.


quote_peg_js : [A]peg A -> string -> prop.
(* TODO: make sure this isn't overly permissive *)
quote_peg_js P S :- reify P P_Reified, quote_term_js P_Reified S.

gen_parse_js P Dict DictRes Result
  when not(builtin P) :-
  quote_peg_js P Key,
  if (map.find Dict Key _)
  then (eq DictRes Dict)
  else (
    get_peg_definition P P',
    eq Dict' ((Key, Expr) :: Dict),
    gen_parse_js P' Dict' DictRes Code,
    expansion.str
    `(function(parsers, input, offset) { const temp = offset; {
        let offset = temp;
        const result = ${Code};
        return { result, offset: offset };
     }})`
     Expr
  ),
  quote_string_js Key Key_js,
  expansion.str 
  `(function() {
     const result = parsers[${Key_js}](parsers, input, offset);
     offset = result.offset;
     return result.result;
   })()`
  Result.

gen_parse_dictionary_js_aux : map string string -> string -> prop.
gen_parse_dictionary_js : map string string -> string -> prop.

gen_parse_dictionary_js_aux Map "" when map.empty Map.

gen_parse_dictionary_js_aux Map Result when map.headtail Map Key Value_js Map' :-
  gen_parse_dictionary_js_aux Map' Result',
  quote_string_js Key Key_js,
  expansion.str
  `${Key_js}: ${Value_js},
   ${Result'}`
  Result.

gen_parse_dictionary_js Map Result :-
  gen_parse_dictionary_js_aux Map Entries_js,
  expansion.str `{
    ${Entries_js}
  }` Result.


parse_opt : [A]peg A -> string -> option (A * string) -> prop.
parse_opt P Input Result :-
  gen_parse_js P [] Dict Code,
  gen_parse_dictionary_js Dict Dict_js,
  quote_string_js Input Input_js,
  expansion.str
  `(function (input, startOffset) {
      const parsers = ${Dict_js};
      let offset = startOffset;
      const result = ${Code};
      if (result === null) {
        return "none";
      } else {
        return \`some ( (\${result}), \${JSON.stringify(input.substr(offset))} )\`;
      }
   })(${Input_js}, 0);`
   FinalCode,
   js.eval FinalCode ResultS,
   fromstring ResultS Result.

(parse_opt (charclass "\nabc\t") "allo!" Res) ?

(parse_opt (bind anychar "a" (fun a => bind anychar "b" (fun b => action `${b}${a}`))) "hi" Res) ?

rep : peg A -> peg (list A).

rule (rep P) (bind P "hd" (fun hd => bind (rep P) "tl" (fun tl => action (hd :: tl)))).
rule (rep P) (action []).

parse_opt (rep (exact "la")) "lalala, lalala!" Y ?

repplus : peg A -> peg (list A).

rule (repplus P) (bind P "hd" (fun hd => bind (rep P) "tl" (fun tl => action (hd :: tl)))).

whitespace : peg unit.
rule whitespace (seq (repplus (charclass " \n\t")) (action unit)).

parse_opt (seq whitespace (action unit)) "   return " Y ?

%end.
