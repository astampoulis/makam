(* we assume an `input` variable holding the input,
   and an `offset` variable holding the index within the input that
   we are looking at.
   the result of a parsing expression is:
   - an expression holding the value part of the result
   - mutation of the offset variable to advance what we're looking at. *)

%extend peg.

gen_parse_js : [A]peg A -> string (* input var *) -> string (* offset var *) -> string (* parser dictionary var *) ->
                           map string string (* input parser dictionary *) ->
                           map string string (* output parser dictionary *) ->
                           string (* result expression *) -> prop.

quote_string_js : string -> string -> prop.

quote_string_js S Res :- tostring S Res.

gen_parse_js anychar Input Offset DictName Dict Dict Result :-
  expansion.str
  `(${Offset} < ${Input}.length ? ${Input}[${Offset}++] : null)`
  Result.

gen_parse_js (charclass S) Input Offset DictName Dict Dict Result :-
  quote_string_js S S_js,
  expansion.str
  `((${Offset} < ${Input}.length && ${S_js}.includes(${Input}[${Offset}])) ? ${Input}[${Offset}++] : null)`
  Result.

gen_parse_js (exact S) Input Offset DictName Dict Dict Result :-
  quote_string_js S S_js,
  expansion.str
  `(${Input}.startsWith(${S_js}, ${Offset})
     ? (${Offset} += ${S_js}.length, ${S_js})
     : null)`
  Result.

gen_parse_js (neg P) Input Offset DictName Dict Dict' Result :-
  gen_parse_js P Input Offset DictName Dict Dict' Code,
  expansion.str
  `(function () { const temp = ${Offset}; {
     let ${Offset} = temp;
     return (${Code} === null ? "unit" : null);
  }})()`
  Result.

gen_parse_js (lookahead P) Input Offset DictName Dict Dict' Result :-
  gen_parse_js P Input Offset DictName Dict Dict' Code,
  expansion.str
  `(function () { const temp = ${Offset}; {
     let ${Offset} = temp;
     return (${Code} === null ? null : "unit");
  }})()`
  Result.

gen_parse_js empty Input Offset DictName Dict Dict Result :-
  expansion.str `"unit"` Result.

gen_parse_js void Input Offset DictName Dict Dict "null".

(* now on to the more difficult ones *)

quote_parse_res_js : [A]A -> string -> prop.

gen_parse_js (bind (P : peg A) Name (F : A -> peg B)) Input Offset DictName Dict Dict'' Result :-
  gen_parse_js P Input Offset DictName Dict Dict' Code,
  (a:A -> quote_parse_res_js a Name ->
   gen_parse_js (F a) Input Offset DictName Dict' Dict'' Code'),
  expansion.str
  `(function() {
     const ${Name} = ${Code};
     return ${Code'};
   })()`
  Result.

gen_parse_js (seq A B) Input Offset DictName Dict Dict'' Result :-
  gen_parse_js A Input Offset DictName Dict Dict' CodeA,
  gen_parse_js B Input Offset DictName Dict' Dict'' CodeB,
  expansion.str
  `(${CodeA}, ${CodeB})`
  Result.

gen_parse_js (choices []) Input Offset DictName Dict Dict "null".

gen_parse_js (choices (HD :: TL)) Input Offset DictName Dict Dict'' Result :-
  gen_parse_js HD Input Offset DictName Dict Dict' CodeHD,
  gen_parse_js (choices TL) Input Offset DictName Dict' Dict'' CodeTL,
  expansion.str
  `(function () {
     const result = ${CodeHD};
     if (result !== null) return result;
     else return ${CodeTL};
   })()`
  Result.

quote_term_js : [A]reified A -> string -> prop.

quote_terms_js : [A B]reified_args A B -> string -> prop.

quote_terms_js [] "".
quote_terms_js (Head :: Tail) Result :-
  quote_term_js Head HeadS,
  quote_terms_js Tail TailS,
  expansion.str ` ${HeadS}${TailS}` Result.

quote_term_js (reified.term Head Args) Result :-
  refl.headname Head HeadS,
  quote_terms_js Args ArgsS,
  expansion.str
  `(${HeadS}${ArgsS})`
  Result.

quote_term_js (reified.const (S : string)) S_js :-
  quote_string_js S S_js.

quote_term_js (reified.const (I : int)) I_js :-
  tostring I I_js.

(* here we need to antiquote the result of `P` *)
quote_term_js (reified.nvar P []) Result :-
  quote_parse_res_js P PRes,
  quote_terms_js Args ArgsS,
  expansion.str `(\${JSON.stringify(${PRes})})` Result.

quote_var_js : [A]A -> string -> prop.
latest_quote_var_js : int -> prop.

latest_quote_var_js 0.

quote_term_js (reified.bvar X Args) Result :-
  quote_var_js X Var,
  quote_terms_js Args ArgsS,
  expansion.str `(${Var}${ArgsS})` Result.

quote_term_js (reified.lambda (F : A -> B)) Result :-
  latest_quote_var_js I,
  tostring I VarI,
  expansion.str `x_${VarI}` Var,
  plus I 1 I',
  (x:A -> quote_var_js x Var -> latest_quote_var_js I' -> quote_term_js (F x) Body),
  expansion.str `(fun ${Var} => ${Body})` Result.

(* TODO: decide if and how unification variables will be supported. *)

gen_parse_js (action X) Input Offset DictName Dict Dict Result :-
  reify X X_Reified,
  quote_term_js X_Reified X_js,
  expansion.str `\`${X_js}\`` Result.


quote_peg_js : [A]peg A -> string -> prop.
(* TODO: make sure this isn't overly permissive *)
quote_peg_js P S :- reify P P_Reified, quote_term_js P_Reified S.

gen_parse_js P Input Offset DictName Dict DictRes Result
  when not(builtin P), quote_peg_js P Key :-
  if (map.find Dict Key _)
  then (eq DictRes Dict)
  else (
    get_peg_definition P P',
    eq Dict' ((Key, Expr) :: Dict),
    gen_parse_js P' Input Offset DictName Dict' DictRes Code,
    expansion.str
    `(function(${DictName}, ${Input}, ${Offset}) { const temp = ${Offset}; {
        let ${Offset} = temp;
        return ${Code};
     }})`
     Expr
  ),
  quote_string_js Key Key_js,
  expansion.str 
  `${DictName}[${Key_js}](${DictName}, ${Input}, ${Offset})`
  Result.

gen_parse_dictionary_js_aux : map string string -> string -> prop.
gen_parse_dictionary_js : map string string -> string -> prop.

gen_parse_dictionary_js_aux Map "" when map.empty Map.

gen_parse_dictionary_js_aux Map Result when map.headtail Map Key Value_js Map' :-
  gen_parse_dictionary_js_aux Map' Result',
  quote_string_js Key Key_js,
  expansion.str
  `${Key_js}: ${Value_js},
   ${Result'}`
  Result.

gen_parse_dictionary_js Map Result :-
  gen_parse_dictionary_js_aux Map Entries_js,
  expansion.str `{
    ${Entries_js}
  }` Result.


(*
%extend js.
eval : string -> string -> prop.
eval S S.
%end.
*)

parse_opt : [A]peg A -> string -> string -> prop.
parse_opt P Input Result :-
  gen_parse_js P "input" "offset" "parsers" [] Dict Code,
  gen_parse_dictionary_js Dict Dict_js,
  quote_string_js Input Input_js,
  expansion.str
  `(function (input, startOffset) {
      const parsers = ${Dict_js};
      let offset = startOffset;
      const result = ${Code};
      if (result === null) {
        return "none";
      } else {
        return \`some((\${result}), \${JSON.stringify(input.substr(offset))})\`;
      }
   })(${Input_js}, 0);`
   FinalCode,
   js.eval FinalCode Result.

(parse_opt (charclass "\nabc\t") "allo!" _Res, print_string _Res) ?

(parse_opt (bind anychar "a" (fun a => bind anychar "b" (fun b => action `${b}${a}`))) "hi" _Res, print_string _Res) ?

testit : peg A -> string -> prop.
testit P Input :- parse_opt P Input Res, print_string Res.

rep : peg A -> peg (list A).

rule (rep P) (bind P "hd" (fun hd => bind (rep P) "tl" (fun tl => action (hd :: tl)))).
rule (rep P) (action []).

testit (rep (exact "la")) "lalala, lalala!" ?

repplus : peg A -> peg (list A).

rule (repplus P) (bind P "hd" (fun hd => bind (rep P) "tl" (fun tl => action (hd :: tl)))).

whitespace : peg unit.
rule whitespace (seq (repplus (charclass " \n\t")) (action unit)).

testit (seq whitespace (action unit)) "   return " ?

%end.
