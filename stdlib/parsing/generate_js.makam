(* we assume an `input` variable holding the input,
             an `offset` (mutable) variable holding the current index within the input,
             the `parsers` dictionary of parsing functions for all the user-defined peg used.
   the result of a parsing expression is:
   - an expression holding the value part of the result
   - mutation of the offset variable to advance what we're looking at
   - a new dictionary with any extra needed parsers *)

gen_parse_js : [A]peg A -> map string string (* input parser dictionary *) ->
                           map string string (* output parser dictionary *) ->
                           string (* result expression *) -> prop.

quote_string_js : string -> string -> prop.

quote_string_js S Res :- tostring S Res.

gen_parse_js anychar Dict Dict Result :-
  expansion.str
  `(offset < input.length
     ? (JSON.stringify(input[offset++]))
     : null)`
  Result.

gen_parse_js (charclass S) Dict Dict Result :-
  quote_string_js S S_js,
  expansion.str
  `((offset < input.length && ${S_js}.includes(input[offset]))
     ? JSON.stringify(input[offset++])
     : null)`
  Result.

gen_parse_js (exact S) Dict Dict Result :-
  quote_string_js S S_js,
  expansion.str
  `(input.startsWith(${S_js}, offset)
    ? (offset += ${S_js}.length, JSON.stringify(${S_js}))
    : null)`
  Result.

gen_parse_js (neg P) Dict Dict' Result :-
  gen_parse_js P Dict Dict' Code,
  expansion.str
  `(function*() {
     const keepOffset = offset;
     const result = ${Code};
     offset = keepOffset;
     return (result === null ? "unit" : null);
  })()`
  Result.

gen_parse_js (lookahead P) Dict Dict' Result :-
  gen_parse_js P Dict Dict' Code,
  expansion.str
  `(yield* (function*() {
     const keepOffset = offset;
     const result = ${Code};
     offset = keepOffset;
     return (result === null ? null : "unit");
  })())`
  Result.

gen_parse_js empty Dict Dict Result :-
  expansion.str `"unit"` Result.

gen_parse_js void Dict Dict "null".

(* now on to the more difficult ones *)

quote_parse_res_js : [A]A -> string -> prop.

latest_parse_res_js : int -> prop.
latest_parse_res_js 0.

gen_parse_js (bind (P : peg A) (F : A -> peg B)) Dict Dict'' Result :-
  gen_parse_js P Dict Dict' Code,
  once(latest_parse_res_js I),
  tostring I IS,
  plus I 1 I',
  expansion.str `result_${IS}` Name,
  (a:A -> quote_parse_res_js a Name -> latest_parse_res_js I' ->
   gen_parse_js (F a) Dict' Dict'' Code'),
  expansion.str
  `(yield* (function*() {
     const keepOffset = offset;
     const ${Name} = ${Code};
     if (${Name} === null) {
       offset = keepOffset;
       return null;
     } else {
       const result = ${Code'};
       if (result === null) {
         offset = keepOffset;
         return null;
       } else return result;
     }
   })())`
  Result.

gen_parse_js (seq A B) Dict Dict'' Result :-
  gen_parse_js A Dict Dict' CodeA,
  gen_parse_js B Dict' Dict'' CodeB,
  expansion.str
  `(yield* (function*() {
     const keepOffset = offset;
     const result = ${CodeA};
     if (result === null) {
       offset = keepOffset;
       return null;
     } else {
       const result = ${CodeB};
       if (result === null) {
         offset = keepOffset;
         return null;
       } else return result;
     }
   })())`
  Result.

gen_parse_js (choices PS) Dict Dict' Result :-
  foldl (pfun cur p next => [DictCur CodeCur DictNext CodeNext CodeP]
    eq cur (DictCur, CodeCur),
    eq next (DictNext, CodeNext),
    gen_parse_js p DictCur DictNext CodeP,
    expansion.str
    `${CodeCur}
     {
       offset = keepOffset;
       const result = ${CodeP};
       if (result !== null) return result;
     }`
    CodeNext) (Dict, "") PS (Dict', Blocks),
  expansion.str
  `(yield* (function*() {
     const keepOffset = offset;
     ${Blocks}
     offset = keepOffset;
     return null;
   })())`
  Result.

quote_term_js : [A]reified A -> string -> prop.

quote_terms_js : [A B]reified_args A B -> string -> prop.

quote_terms_js X Result
  when refl.isunif X, locget X X_Loc, tostring X_Loc LocS, print_string `At ${LocS}, uninstantiated reified arguments.\n`.

quote_terms_js [] "".
quote_terms_js (Head :: Tail) Result :-
  quote_term_js Head HeadS,
  quote_terms_js Tail TailS,
  expansion.str ` ${HeadS}${TailS}` Result.

quote_term_js (reified.term Head Args) Result :-
  refl.headname Head HeadS,
  quote_terms_js Args ArgsS,
  expansion.str
  `(${HeadS}${ArgsS})`
  Result.

quote_term_js (reified.const (S : string)) S_js :-
  quote_string_js S S_js.

quote_term_js (reified.const (I : int)) I_js :-
  tostring I I_js.

(* here we need to antiquote the result of `P` *)
quote_term_js (reified.nvar P []) Result :-
  quote_parse_res_js P PRes,
  expansion.str `(\${${PRes}})` Result.

quote_var_js : [A]A -> string -> prop.
latest_quote_var_js : int -> prop.

latest_quote_var_js 0.

quote_term_js (reified.bvar X Args) Result :-
  quote_var_js X Var,
  quote_terms_js Args ArgsS,
  expansion.str `(${Var}${ArgsS})` Result.

quote_term_js (reified.lambda (F : A -> B)) Result :-
  once(latest_quote_var_js I),
  tostring I VarI,
  expansion.str `x_${VarI}` Var,
  plus I 1 I',
  (x:A -> quote_var_js x Var -> latest_quote_var_js I' ->
    (quote_term_js (F x) Body, refl.typstring x Typ)),
  expansion.str `(fun (${Var}: ${Typ}) => ${Body})` Result.

(* TODO: decide if and how unification variables will be supported. *)

gen_parse_js (action X) Dict Dict Result :-
  reify X X_Reified,
  quote_term_js X_Reified X_js,
  expansion.str `\`${X_js}\`` Result.


quote_peg_js : [A]peg A -> string -> prop.
(* TODO: make sure this isn't overly permissive *)
quote_peg_js P S :- reify P P_Reified, quote_term_js P_Reified S.

gen_parse_js P Dict DictRes Result
  when not(builtin P) :-
  quote_peg_js P Key,
  quote_string_js Key Key_js,
  if (map.find Dict Key _)
  then (eq DictRes Dict)
  else (
    get_peg_definition P P',
    eq Dict' ((Key, Expr) :: Dict),
    gen_parse_js P' Dict' DictRes Code,
    expansion.str
    `(function*() {
      const historyEntry = \`${Key}:\${offset}\`;
      const keepOffset = offset;
      if (history.includes(historyEntry)) {
        throw new Error(\`left recursion found: adding \${historyEntry} to \${history}\`);
      }
      if (memoize[${Key_js}][keepOffset] !== undefined) {
        const { result, newOffset } = memoize[${Key_js}][keepOffset];
        offset = newOffset;
        return result;
      } else {
        let historyCopy = history.slice();
        history.push(historyEntry);
        const result = ${Code};
        memoize[${Key_js}][keepOffset] = { result, newOffset: offset };
        history = historyCopy;
        return result;
      }
     })`
     Expr
  ),
  expansion.str 
  `yield ${Key_js}`
  Result.

gen_dictionary_js_aux : map string string -> string -> prop.
gen_dictionary_js : map string string -> string -> prop.

gen_dictionary_js_aux Map "" when map.empty Map.

gen_dictionary_js_aux Map Result when map.headtail Map Key Value_js Map' :-
  gen_dictionary_js_aux Map' Result',
  quote_string_js Key Key_js,
  expansion.str
  `${Key_js}: ${Value_js},
   ${Result'}`
  Result.

gen_dictionary_js Map Result :-
  gen_dictionary_js_aux Map Entries_js,
  expansion.str `{
    ${Entries_js}
  }` Result.


parse_opt : [A] peg A -> string -> (A * string) -> prop.

gen_toplevel_parser_js : [A] peg A -> string -> prop.
gen_toplevel_parser_js P Function_js :-
  gen_parse_js P [] Dict Code,
  gen_dictionary_js Dict Dict_js,
  map.mapvalues (pfun _ => eq "{}") Dict MemoizeDict,
  gen_dictionary_js MemoizeDict MemoizeDict_js,
  expansion.str
  `(function (input, startOffset) {
      let offset = startOffset;
      const parsers = ${Dict_js};
      const memoize = ${MemoizeDict_js};
      let history = [];
      const firstGen = (function*() { return ${Code}; })();
      const recurseOrResult = [ { gen: firstGen, val: firstGen.next() } ];
      let lastRes;
      while (recurseOrResult.length > 0) {
        const { gen: genTop, val: valTop } = recurseOrResult[recurseOrResult.length-1];
        if (valTop.done) {
          lastRes = valTop.value;
          recurseOrResult.pop();
          if (recurseOrResult.length > 0) {
            const { gen, val } = recurseOrResult[recurseOrResult.length - 1];
            recurseOrResult[recurseOrResult.length - 1] = { gen, val: gen.next(lastRes) };
          }
        } else {
          const nextGen = parsers[valTop.value]();
          recurseOrResult.push( {gen: nextGen, val: nextGen.next() } );
        }
      }
      if (lastRes === null) {
        return "none";
      } else {
        return \`some ( (\${lastRes}), \${JSON.stringify(input.substr(offset))} )\`;
      }
   })`
   Function_js.

eval_parser_js : string -> string -> A -> prop.

eval_parser_js Function_js Input Result :-
  quote_string_js Input Input_js,
  expansion.str `${Function_js}(${Input_js}, 0);` FinalCode,
  js.eval FinalCode ResultS,
  fromstring ResultS (some Result).

cached_prop, actual_cached_prop : [A](A -> prop) -> A -> prop.
cached_prop P Res :-
  if (actual_cached_prop P Res) then success else P Res.

cache_prop : (A -> prop) -> cmd -> prop.
cache_prop P (cmd_newclause (clause (actual_cached_prop P Result) success)) :-
  P Result.

def_parser_js : [A]peg A -> cmd -> prop.
def_parser_js P Cmd :- cache_prop (gen_toplevel_parser_js P) Cmd.

parse_opt P Input Result :-
  cached_prop (gen_toplevel_parser_js P) Function_js,
  eval_parser_js Function_js Input Result.
