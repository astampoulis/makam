%extend peg.
%extend layout.

available : [A] A -> prop.
actually_available : prop.

enter : peg A -> peg A.

current_line_offset : peg int.
current_layout_offset : peg int.

ws : peg unit.
ws_opt : peg unit.

begin : peg int.
next : int -> peg unit.
end : int -> peg unit.

block : (peg unit -> peg A) -> peg A.

%end.
%end.

%open peg.

(* layout is only available locally, through an assumption. *)
layout.available P :-
  if (layout.actually_available) then success
  else (
    log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``,
    failure
  ).

external (layout.enter P).
extern_def (layout.enter P) Code :-
  if (layout.actually_available)
  then (log_error P `layout already available in context, only enclose top-level expression needing layout with \`layout.enter\``, failure)
  else success,
  (layout.actually_available -> gen_toplevel_parser_js P InnerCode),
  expansion.str
  `function (input, startOffset) {
     const currentLineOffset = (offset) => {
       const lastNewlineOffset = input.lastIndexOf("\\n", offset);
       const lastCarret = input.lastIndexOf("\\r", offset);
       const lastLineOffset = Math.max(lastNewlineOffset, lastCarret);
       return JSON.stringify(lastLineOffset == -1 ? offset : offset - lastLineOffset - 1);
     };

     const layoutOffsets = [ { stringOffset: startOffset, layoutOffset: currentLineOffset(startOffset) } ];

     const previousLayoutOffset = (offset) => {
       const previous = layoutOffsets.slice().reverse().find(({stringOffset}) => stringOffset <= offset);
       return JSON.stringify(previous.layoutOffset);
     };
     const addLayoutOffset = (stringOffset, layoutOffset) => {
       if (layoutOffsets.find(x => x.stringOffset === stringOffset)) return;
       layoutOffsets.push({stringOffset, layoutOffset});
       layoutOffsets.sort((a, b) => a.stringOffset - b.stringOffset);
     };
     return ${InnerCode}(input, startOffset);
  }`
  Code.

rule layout.current_line_offset P' when layout.available P' :-
  eq P' (eval `return currentLineOffset(offset);`).

rule layout.current_layout_offset P' when layout.available P' :-
  eq P' (eval `return previousLayoutOffset(offset);`).

rule layout.begin P' when layout.available P' :-
  eq P'
  (bind layout.current_layout_offset (fun current_layout_offset =>
  (seq ws (bind layout.current_line_offset (fun new_layout_offset =>
    eval `
      if (${jsresult new_layout_offset} > ${jsresult current_layout_offset}) {
        addLayoutOffset(offset, ${jsresult new_layout_offset});
        return ${result new_layout_offset};
      } else return null;
    `))))).

rule (layout.next I) P' when layout.available P' :-
  eq P'
  (bind (action I) (fun current_layout_offset =>
  (seq ws_opt (bind layout.current_line_offset (fun current_line_offset =>
    eval `
      if (${jsresult current_layout_offset} == ${jsresult current_line_offset}) {
        addLayoutOffset(offset, ${jsresult current_layout_offset});
        return "unit";
      } else {
        return null;
      }
    `))))).

rule (layout.end I) P' when layout.available P' :-
  eq P'
  (bind (action I) (fun current_layout_offset =>
  (seq ws_opt (bind layout.current_line_offset (fun new_layout_offset =>
    choices [
      seq eof (eval `return "unit";`),
      eval `
        if (${jsresult new_layout_offset} < ${jsresult current_layout_offset}) {
          addLayoutOffset(offset, ${jsresult new_layout_offset});
          return "unit";
        } else {
          return null;
        }
      `
    ]))))).

rule (layout.ws_opt) (ignore (option layout.ws)).

rule layout.ws
  (ignore (bind layout.current_layout_offset (fun current_layout_offset =>
    once_or_many (choices [
      (* whitespace without line breaks *)
      ignore (once_or_many (charclass " \t")),
      (* consume whitespace lines *)
      seq (once_or_many (charclass "\r\n")) (seq (many (charclass " \t")) (lookahead (once_or_many (charclass "\r\n")))),
      (* line break followed by the same or more whitespace than current layout offset *)
      seq (once_or_many (charclass "\r\n")) (seq (many (charclass " \t"))
        (bind layout.current_line_offset (fun current_line_offset =>
        (eval `return ${jsresult current_line_offset} > ${jsresult current_layout_offset} ? "unit" : null;`))))
    ])))).

rule (layout.block Main)
     (bind layout.begin (fun i => bind (Main (layout.next i)) (fun res => seq (layout.end i) (action res)))).
