%extend peg.
%extend layout.

available : prop.

enter : peg A -> peg A.

current_line_offset : peg int.
current_layout_offset : peg int.

ws : peg unit.
ws_opt : peg unit.

begin : peg int.
next : int -> peg unit.
end : int -> peg unit.

block : (peg unit -> peg A) -> peg A.

%end.
%end.

%open peg.

external (layout.enter P).
extern_def (layout.enter P) Code :-
  if (layout.available)
  then (log_error P `layout already available in context, only enclose top-level expression needing layout with \`layout.enter\``, failure)
  else success,
  (layout.available -> gen_toplevel_parser_js P InnerCode),
  expansion.str
  `function (input, startOffset) {
     const currentLineOffset = (offset) => {
       const lastNewlineOffset = input.lastIndexOf("\\n", offset);
       const lastCarret = input.lastIndexOf("\\r", offset);
       const lastLineOffset = Math.max(lastNewlineOffset, lastCarret);
       return JSON.stringify(lastLineOffset == -1 ? offset : offset - lastLineOffset - 1);
     };

     const layoutOffsets = [ { stringOffset: startOffset, layoutOffset: currentLineOffset(startOffset) } ];

     const previousLayoutOffset = (offset) => {
       const previous = layoutOffsets.slice().reverse().find(({stringOffset}) => stringOffset <= offset);
       return JSON.stringify(previous.layoutOffset);
     };
     const addLayoutOffset = (stringOffset, layoutOffset) => {
       if (layoutOffsets.find(x => x.stringOffset === stringOffset)) return;
       layoutOffsets.push({stringOffset, layoutOffset});
       layoutOffsets.sort((a, b) => a.stringOffset - b.stringOffset);
     };
     return ${InnerCode}(input, startOffset);
  }`
  Code.

rule P P' when eq P layout.current_line_offset :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``, failure),
  eq P' (eval `return currentLineOffset(offset);`).

rule P P' when eq P layout.current_layout_offset :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``, failure),
  eq P' (eval `return previousLayoutOffset(offset);`).

rule P P' when eq P layout.begin :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``, failure),
  eq P'
  (bind layout.current_layout_offset (fun current_layout_offset =>
  (seq ws (bind layout.current_line_offset (fun new_layout_offset =>
    eval `
      if (${jsresult new_layout_offset} > ${jsresult current_layout_offset}) {
        addLayoutOffset(offset, ${jsresult new_layout_offset});
        return ${result new_layout_offset};
      } else return null;
    `))))).

rule P P' when eq P (layout.next I) :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``, failure),
  eq P'
  (bind (action I) (fun current_layout_offset =>
  (seq ws_opt (bind layout.current_line_offset (fun current_line_offset =>
    eval `
      if (${jsresult current_layout_offset} == ${jsresult current_line_offset}) {
        addLayoutOffset(offset, ${jsresult current_layout_offset});
        return "unit";
      } else {
        return null;
      }
    `))))).

rule P P' when eq P (layout.end I) :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``, failure),
  eq P'
  (bind (action I) (fun current_layout_offset =>
  (seq ws_opt (bind layout.current_line_offset (fun new_layout_offset =>
    choices [
      seq eof (eval `return "unit";`),
      eval `
        if (${jsresult new_layout_offset} < ${jsresult current_layout_offset}) {
          addLayoutOffset(offset, ${jsresult new_layout_offset});
          return "unit";
        } else {
          return null;
        }
      `
    ]))))).

rule (layout.ws_opt) (ignore (option layout.ws)).

rule P P' when eq P layout.ws :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``, failure),
  eq P'
  (ignore (bind layout.current_layout_offset (fun current_layout_offset =>
    once_or_many (choices [
      (* whitespace without line breaks *)
      ignore (once_or_many (charclass " \t")),
      (* consume whitespace lines *)
      seq (once_or_many (charclass "\r\n")) (seq (many (charclass " \t")) (lookahead (once_or_many (charclass "\r\n")))),
      (* line break followed by the same or more whitespace than current layout offset *)
      seq (once_or_many (charclass "\r\n")) (seq (many (charclass " \t"))
        (bind layout.current_line_offset (fun current_line_offset =>
        (eval `return ${jsresult current_line_offset} > ${jsresult current_layout_offset} ? "unit" : null;`))))
    ])))).

rule P P' when eq P (layout.block Main) :-
  if layout.available then success
  else (log_error P `layout not available in context, enclose top-level peg expression with \`layout.enter\``),
  eq P' (bind layout.begin (fun i => bind (Main (layout.next i)) (fun res => seq (layout.end i) (action res)))).



%extend layout_grammar_tests.

all : testsuite. %testsuite all.

>> parse_opt (layout.enter (seq ws layout.current_line_offset)) "\n  hello" (X, _) ?
>> Yes:
>> X := 2.

>> parse_opt (layout.enter (seq (seq ws (seq (exact "hello") ws)) layout.current_line_offset)) "\n  hello\r   foo" (X, _) ?
>> Yes:
>> X := 3.

>> parse_opt (layout.enter (seq ws_opt (seq (exact "do") (seq layout.begin (seq (once_or_many (charclass "abcdefghijklmnopqrstuvwxyz")) (seq ws layout.current_layout_offset)))))) {
     do foo
        bar
   } (X, _) ?
>> Yes:
>> X := 8.

rosetree : type.
rosetree_aux, rosetree : peg rosetree.
rosetree : string -> list rosetree -> rosetree.

label : peg string.

rule label (syntax (syntax.char_once_or_many (syntax.charclass "abcdefghijklmnopqrstuvwxyz"))).

rule rosetree_aux (
  apply rosetree [
    captured label,
    captured (choices [layout.block (fun sep => many (seq sep rosetree_aux)), action []])
  ]).
rule rosetree (seq ws_opt (layout.enter rosetree_aux)).

`( def_toplevel_parser_js rosetree ).

>> parse_opt rosetree {
 foo bar
     baz
 } X ?
>> Yes:
>> X := (rosetree "foo" [ rosetree "bar" [], rosetree "baz" [] ], "").

>> parse_opt rosetree {
 foo
   bar
     roo
     noo
   baz
     roo
     noo
 } X ?
>> Yes:
>> X := (rosetree "foo" [ rosetree "bar" [ rosetree "roo" [], rosetree "noo" [] ], rosetree "baz" [ rosetree "roo" [], rosetree "noo" [] ] ], "").

>> parse_opt rosetree {
 foo bar baz
     roo noo
     baa  daa
          naa
 } X ?
>> Yes:
>> X := (rosetree "foo" [ rosetree "bar" [ rosetree "baz" [] ], rosetree "roo" [ rosetree "noo" [] ], rosetree "baa" [ rosetree "daa" [], rosetree "naa" [] ] ], "").

>> parse_opt rosetree {
 foo bar} X ?
>> Yes:
>> X := (rosetree "foo" [ rosetree "bar" [] ], "").

>> parse_opt rosetree {
 foo


   bar

   baz} X ?
>> Yes:
>> X := (rosetree "foo" [ rosetree "bar" [], rosetree "baz" [] ], "").

>> parse_opt rosetree {
    foo
 lala
} X ?
>> Yes:
>> X := (rosetree "foo" [ ], "\n lala\n").

%end.
