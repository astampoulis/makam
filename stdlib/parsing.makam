peg : type -> type.

action_peg : type -> type.

bind : peg A -> (A -> action_peg B) -> action_peg B.
concat : peg A -> action_peg B -> action_peg B.
action : B -> action_peg B.
choices : list (action_peg A) -> action_peg A.
lift : peg A -> action_peg A.

anychar : peg string. 
charclass : string -> peg string.
char : string -> peg string.
neg : peg A -> peg A.
lookahead : peg A -> peg unit.
option : peg A -> peg (option A).
choice : peg A -> peg A -> peg A.
empty : peg unit.
void : peg A.
inject : action_peg A -> peg A.

%extend peg.
builtin : [A] peg A -> prop. (* used to tell if something is one of the builtins or a peg defined in terms of those *)

builtin anychar.
builtin (charclass _).
builtin (char _).
builtin (neg _).
builtin (lookahead _).
builtin (option _).
builtin (choice _ _).
builtin (empty).
builtin (void).
builtin (inject _).
%end.

parse : [A]peg A -> list string -> option (A * list string) -> prop.
parse : [A]action_peg A -> list string -> option (A * list string) -> prop.


parse (bind PegA PegB) S Res :-
  if (parse PegA S (some (A, S'))) then
     parse (PegB A) S' Res
  else
     eq Res none.

parse (concat PegA PegB) S Res :-
  if (parse PegA S (some (_, S'))) then
     parse PegB S' Res
  else
     eq Res none.

parse (action B) S (some (B, S)).

parse (choices []) S none.

parse (choices (HD :: TL)) S Res :-
  if (parse HD S (some R)) then
    eq Res (some R)
  else
    parse (choices TL) S Res.

parse (lift Peg) S Res :-
  parse Peg S Res.

parse (anychar) [] none.

parse (anychar) (HD :: TL) (some (HD, TL)).

parse (charclass S) (HD :: TL) (some (HD, TL)) :-
  if (string.contains S HD) then
    eq Res (some (HD, TL))
  else
    eq Res none.

parse (char S) (HD :: TL) Res :-
  if (eq S HD) then
    eq Res (some (HD, TL))
  else
    eq Res none.

parse (neg P) S Res :-
  if (parse P S (some _)) then
    eq Res none
  else
    eq Res (some (unit, S)).

parse (lookahead P) S Res :-
  if (parse P S (some _)) then
    eq Res (some (unit, S))
  else
    eq Res none.

parse (option P) S Res :-
  if (parse P S (some (A, S'))) then
    eq Res (some (some A, S'))
  else
    eq Res (some (none, S)).

parse (empty) S (some (unit, S)).

parse (void) S none.

parse (inject ActionPeg) S Res :- parse ActionPeg S Res.


%extend peg.
rule : [A] peg A -> action_peg A -> prop.
%end.

parse P S Res when not(peg.builtin P) :-
  refl.rules_get (peg.rule P _) Rules,
  map (pfun rule res => [Def Loc LocS]
    if (eq rule (clause (peg.rule P Def) success)) then
      eq res Def
    else
      (locget rule Loc, tostring Loc LocS, 
       print_string "\n-- Error at PEG definition rule at ", print_string LocS, print_string "\n",
       failure))
  Rules Defs,
  parse (choices Defs) S Res.

parse : [A] action_peg A -> string -> A -> prop.

parse PegA S A :- string.explode S CharList, parse PegA CharList (some (A, [])).


parsing : testsuite. %testsuite parsing.

>> (parse (bind anychar (fun a => bind anychar (fun b => action (fun s => {prop| string.explode s [b, a] |})))) "hi" Res, Res S) ?
>> Yes:
>> S := "ih".

>> (parse (bind anychar (fun a => concat (charclass " \n\t") (action a))) "a " Res) ?
>> Yes:
>> Res := "a".


rep : peg A -> peg (list A).

peg.rule (rep P) (bind P (fun hd => bind (rep P) (fun tl => action (hd :: tl)))).
peg.rule (rep P) (action []).

parse (lift (rep (exact "a"))) "aaa" Res ?
>> Yes:
>> Res := [ "a", "a", "a" ].

