(* TODO: applicable_rules_get optimization *)
(* TODO: namespace everything below peg? *)

peg : type -> type.

bind : peg A -> (A -> peg B) -> peg B.
seq : peg A -> peg B -> peg B.
action : B -> peg B.
choices : list (peg A) -> peg A.

anychar : peg string. 
charclass : string -> peg string.
exact : string -> peg string.
neg : peg A -> peg A.
lookahead : peg A -> peg unit.
option : peg A -> peg (option A).
empty : peg unit.
void : peg A.

%extend peg.
builtin : [A] peg A -> prop. (* used to tell if something is one of the builtins or a peg defined in terms of those *)

builtin (bind _ _).
builtin (seq _ _).
builtin (action _).
builtin (choices _).
builtin anychar.
builtin (charclass _).
builtin (exact _).
builtin (neg _).
builtin (lookahead _).
builtin (option _).
builtin (empty).
builtin (void).
%end.

parse : [A]peg A -> list string -> option (A * list string) -> prop.


parse (bind PegA PegB) S Res :-
  if (parse PegA S (some (A, S'))) then
     parse (PegB A) S' Res
  else
     eq Res none.

parse (seq PegA PegB) S Res :-
  if (parse PegA S (some (_, S'))) then
     parse PegB S' Res
  else
     eq Res none.

parse (action B) S (some (B, S)).

parse (choices []) S none.

parse (choices (HD :: TL)) S Res :-
  if (parse HD S (some R)) then
    eq Res (some R)
  else
    parse (choices TL) S Res.


parse (anychar) [] none.

parse (anychar) (HD :: TL) (some (HD, TL)).

parse (charclass S) (HD :: TL) Res :-
  if (string.contains S HD) then
    eq Res (some (HD, TL))
  else
    eq Res none.

parse (exact S) Input Res :-
  string.explode S List,
  if (append List Rest Input) then
    eq Res (some (S, Rest))
  else
    eq Res none.

parse (neg P) S Res :-
  if (parse P S (some _)) then
    eq Res none
  else
    eq Res (some (unit, S)).

parse (lookahead P) S Res :-
  if (parse P S (some _)) then
    eq Res (some (unit, S))
  else
    eq Res none.

parse (option P) S Res :-
  if (parse P S (some (A, S'))) then
    eq Res (some (some A, S'))
  else
    eq Res (some (none, S)).

parse (empty) S (some (unit, S)).

parse (void) S none.


%extend peg.
rule : [A] peg A -> peg A -> prop.
%end.

parse P S Res when not(peg.builtin P) :-
  refl.rules_get_applicable (peg.rule P _) Rules,

  map (pfun rule res => [Def Loc LocS]
    if (eq rule (clause (peg.rule P Def) success)) then
      eq res Def
    else
      (locget rule Loc, tostring Loc LocS, 
       print_string "\n-- Error at PEG definition rule at ", print_string LocS, print_string "\n",
       failure))
  Rules Defs,
  parse (choices Defs) S Res.

parse : [A] peg A -> string -> (A * string) -> prop.

parse PegA S (A, S') :- string.explode S CharList, parse PegA CharList (some (A, Rest)), string.explode S' Rest.




parsing : testsuite. %testsuite parsing.

>> (parse (bind anychar (fun a => bind anychar (fun b => action (fun s => {prop| string.explode s [b, a] |})))) "hi" (_DoIt, Rest), _DoIt S) ?
>> Yes:
>> S := "ih",
>> Rest := "".

>> parse (bind anychar (fun a => seq (charclass " \n\t") (action a))) "a " Res ?
>> Yes:
>> Res := ("a", "").

>> parse (bind anychar (fun a => seq (charclass " \n\t") (action a))) "a !" Res ?
>> Yes:
>> Res := ("a", "!").

rep : peg A -> peg (list A).

peg.rule (rep P) (bind P (fun hd => bind (rep P) (fun tl => action (hd :: tl)))).
peg.rule (rep P) (action []).

>> parse (rep (exact "hi")) "hihi" Res ?
>> Yes:
>> Res := ([ "hi", "hi" ], "").

repplus : peg A -> peg (list A).

peg.rule (repplus P) (bind P (fun hd => bind (rep P) (fun tl => action (hd :: tl)))).

whitespace : peg unit.
peg.rule whitespace (seq (repplus (charclass " \n\t")) (action unit)).

>> parse (seq whitespace (action unit)) "   return " Res ?
>> Yes:
>> Res := (unit, "return ").

token : peg A -> peg A.
peg.rule (token P) (seq (option whitespace) P).

>> parse (seq (token (exact "return")) (token (exact "true"))) " return true " Res ?
>> Yes:
>> Res := ("true", " ").

ident : type.
ident : list string -> ident.

ident : peg ident.
identfirst, identrest : peg string.

peg.rule identfirst (charclass "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZαβγδεζηθικμνξοπρστυφχψωΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ_").
peg.rule identrest (charclass "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZαβγδεζηθικλμνξοπρστυφχψωΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ_1234567890'").

peg.rule ident (bind identfirst (fun hd => bind (rep identrest) (fun tl => action (ident (hd :: tl))))).

cterm : type.
clam : ident -> cterm -> cterm.
cvar : ident -> cterm.
capp : cterm -> list cterm -> cterm.

cterm, cterm0, cterm1, cterm2 : peg cterm.

peg.rule cterm cterm0.

peg.rule cterm0 (seq (token (exact "λ")) (bind (token ident) (fun var => seq (token (exact "."))
                 (bind cterm0 (fun body => action (clam var body)))))).

peg.rule cterm0 cterm1.

peg.rule cterm1 (bind cterm2 (fun hd => bind (repplus (seq whitespace cterm2)) (fun tl => action (capp hd tl)))).

peg.rule cterm1 cterm2.

peg.rule cterm2 (bind (token ident) (fun var => action (cvar var))).

peg.rule cterm2 (seq (token (exact "(")) (bind cterm0 (fun t => seq (token (exact ")")) (action t)))).

>> parse cterm "λ x.x" Res ?
>> Yes:
>> Res := (clam (ident ["x"]) (cvar (ident ["x"])), "").

>> parse cterm "λf.λg.λx.f (g x)" Res ?
>> Yes:
>> Res := ((clam (ident (cons "f" nil)) (clam (ident (cons "g" nil)) (clam (ident (cons "x" nil)) (capp (cvar (ident (cons "f" nil))) (cons (capp (cvar (ident (cons "g" nil))) (cons (cvar (ident (cons "x" nil))) nil)) nil))))), "").
