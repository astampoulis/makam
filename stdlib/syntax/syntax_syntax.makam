(* This implements a syntax for syntax combinators --
   basically a `syntax (syntax A)` syntax procedure,
   which we can use to define syntax for other types.

   Due to the typed nature of `syntax`, typeful parsing
   does not really work; so we parse syntax combinators
   into a string representing a makam term; when this
   string is parsed with `refl.fromstring` we'll get something
   of `syntax A` type. The pretty-printer does work normally,
   so the syntax of syntax is defined through `rule_iso`,
   handling parsing and pretty-printing differently.
*)

%open syntax.
%open peg.
%open pretty.

%extend syntax_syntax.

ident : syntax string.
makam_ident : syntax string.
string_literal : syntax string.

makam_term : pretty A.

top_str : peg string.
args_str : peg string.

top : pretty (syntax A).
args : pretty (syntax_args A B).

top : syntax (syntax A).
args : syntax (syntax_args A B).


(* TODO: `ident` should be more precise than that *)
rule ident (group [optunit ws_space, syntax.captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz")), optunit ws_empty ]).

(* TODO: we should allow makam terms other than `ident` below *)
rule makam_ident (group [optunit ws_space, syntax.captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz._")), optunit ws_empty ]).

(* TODO: string literals should be more general than this too *)
rule string_literal
     (group [optunit ws_space,
      exact "'",
      syntax.captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyzαβγδεζηθικλμνξοπρστυφχψω!@#$%^&*()-=+_;:<>[]{}.\/?")),
      exact "'", optunit ws_empty]).

token : string -> syntax unit.
inline (token _).
syntax.rule (token S) (apply unit [ optunit ws_space, exact S, optunit ws_empty ]).

peg.rule top_str
          (string_transform (fun id args => expansion.str `(syntax.apply ${id} ${args})`)
          [ peg.captured (syntax makam_ident), syntax (token "{"), peg.captured args_str, syntax (token "}") ]).
peg.rule args_str
     (string_transform (fun hd tl => expansion.str `(syntax.cons (syntax.captured ${hd}) ${tl})`)
            [ syntax (token "["),
              peg.captured (syntax makam_ident),
              syntax (token "]"),
              peg.captured args_str ]).
peg.rule args_str
     (string_transform (fun hd tl => expansion.str `(syntax.cons (syntax_syntax.token "${hd}") ${tl})`)
            [ peg.captured (syntax string_literal),
              peg.captured args_str ]).
peg.rule args_str
     (string_transform (fun hd tl => expansion.str `(syntax.cons ${hd} ${tl})`)
            [ peg.captured (syntax makam_ident),
              peg.captured args_str ]).
peg.rule args_str
     (string_transform (eq "syntax.nil") []).

pretty.rule top
     (unapply syntax.apply
      [ pretty.captured makam_term, syntax (token "{"), pretty.captured args, syntax (token "}") ]).
pretty.rule args
     (unapply (fun hd tl => syntax.cons (syntax.captured hd) tl)
       [ syntax (token "["),
         pretty.captured makam_term,
         syntax (token "]"),
         pretty.captured args ]).
pretty.rule args
     (unapply (fun hd tl => syntax.cons (token hd: syntax unit) tl)
       [ pretty.captured (syntax string_literal),
         pretty.captured args ]).
pretty.rule args
     (unapply (syntax.cons : syntax unit -> syntax.syntax_args B C -> syntax.syntax_args B C)
       [ pretty.captured makam_term,
         pretty.captured args ]).
pretty.rule args
     (unapply syntax.nil []).

pretty.rule makam_term
     (untransform (pfun res str => refl.headname str res)
       [ pretty.captured (syntax makam_ident) ]).

syntax.rule_iso top
         (peg.transform refl.fromstring "JSON.parse" [ peg.captured top_str ])
         (top).

syntax.rule_iso args
         (peg.transform refl.fromstring "JSON.parse" [ peg.captured args_str ])
         (args).

top_dyn : syntax dyn.
args_dyn : syntax dyn.

rule top_dyn (apply dyn [ syntax.captured top ]).
rule args_dyn (apply dyn [ syntax.captured args ]).

`( syntax.def_js args_dyn ).

new_rule : [A B] syntax A -> B -> string -> cmd -> prop.
new_rule Syntax Constructor Args_S
         (cmd_newclause (clause
           (syntax.rule Syntax (syntax.apply Constructor Args))
           success)) :-
  if (parse_opt args_dyn Args_S (dyn Args_Untyped))
  then
    (if (dyn.eq Args_Untyped Args)
     then success
     else (if (refl.typstring Args_Untyped TypArgsS')
           then expansion.str `(${TypArgsS'}) ` TypArgsS
           else eq TypArgsS "",
           if (refl.typstring Args TypConstrS')
           then expansion.str `(${TypConstrS'}) ` TypConstrS
           else eq TypConstrS "",
           log_error Args_S `type of syntax arguments ${TypArgsS}does not match type of constructor${TypConstrS}`, failure))
  else (log_error Args_S `parsing the syntax rule failed`, failure).

%end.

%open syntax_syntax.

%extend syntax_syntax_tests.

term : type.
term : syntax term.

lam : string -> term -> term.
app : term -> term -> term.
var : string -> term.

all : testsuite. %testsuite all.

(* TODO: make tostring/fromstring more robust for cases like below. *)

>> syntax.parse_opt top_dyn "syntax_syntax_tests.lam { 'λ' [syntax_syntax.ident] '.' [syntax_syntax_tests.term] }" (dyn X) ?
>> Yes:
>> X := (syntax.apply lam [token "λ", syntax.captured ident, token ".", syntax.captured term]).

>> syntax.pretty top (syntax.apply lam [token "λ", syntax.captured ident, token ".", syntax.captured term]) X ?
>> Yes:
>> X := " syntax_syntax_tests.lam { 'λ' [ syntax_syntax.ident ] '.' [ syntax_syntax_tests.term ] }".

`( new_rule term lam "'λ' [ident] '.' [term]" ).
`( new_rule term var "[ident]" ).
`( new_rule term app "'(' [term] [term] ')'" ).

`( def_js term ).

>> syntax.parse_opt term "λx.λy.((y x) x)" X ?
>> Yes:
>> X := lam "x" (lam "y" (app (app (var "y") (var "x")) (var "x"))).

>> syntax.pretty term (lam "x" (lam "y" (app (app (var "y") (var "x")) (var "x")))) X ?
>> Yes:
>> X := " λ x . λ y . ( ( y x ) x )".

%end.
