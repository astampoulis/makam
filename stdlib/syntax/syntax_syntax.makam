(* This implements a syntax for syntax combinators --
   basically a `syntax (syntax A)` syntax procedure,
   which we can use to define syntax for other types.

   Due to the typed nature of `syntax`, typeful parsing
   does not really work; so we parse syntax combinators
   into a string representing a makam term; when this
   string is parsed with `refl.fromstring` we'll get something
   of `syntax A` type. The pretty-printer does work normally,
   so the syntax of syntax is defined through `rule_iso`,
   handling parsing and pretty-printing differently.
*)

%extend syntax_syntax.

ident : syntax string.
makam_ident : syntax string.
string_literal : syntax string.

ssyntax_str : peg.peg string.
ssyntax_args_str : peg.peg string.

ssyntax : pretty.pretty (syntax A).
ssyntax_args : pretty.pretty (syntax.syntax_args A B).
makam_term : pretty.pretty A.

%end.

%extend syntax.

(* TODO: `ident` should be more precise than that *)
rule syntax_syntax.ident (group [optunit ws_space, captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz")), optunit ws_empty ]).

(* TODO: we should allow makam terms other than `ident` below *)
rule syntax_syntax.makam_ident (group [optunit ws_space, captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz._")), optunit ws_empty ]).

(* TODO: string literals should be more general than this too *)
rule syntax_syntax.string_literal
                           (group [optunit ws_space, exact "'",
                            captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyzαβγδεζηθικλμνξοπρστυφχψω!@#$%^&*()-=+_;:<>[]{}.\/?")),
                            exact "'", optunit ws_empty]).

token : string -> syntax unit.
inline (token _).
rule (token S) (apply unit [ optunit ws_space, exact S, optunit ws_empty ]).

%end.

%extend peg.

rule syntax_syntax.ssyntax_str
          (string_transform (fun id args => expansion.str `(syntax.apply ${id} ${args})`)
          [ captured (syntax syntax_syntax.makam_ident), (syntax (syntax.token "{")), captured syntax_syntax.ssyntax_args_str, (syntax (syntax.token "}")) ]).
rule syntax_syntax.ssyntax_args_str
     (string_transform (fun hd tl => expansion.str `(syntax.cons (syntax.captured ${hd}) ${tl})`)
            [ syntax (syntax.token "["),
              captured (syntax syntax_syntax.makam_ident),
              syntax (syntax.token "]"),
              captured syntax_syntax.ssyntax_args_str ]).
rule syntax_syntax.ssyntax_args_str
     (string_transform (fun hd tl => expansion.str `(syntax.cons (syntax.token "${hd}") ${tl})`)
            [ captured (syntax syntax_syntax.string_literal),
              captured syntax_syntax.ssyntax_args_str ]).
rule syntax_syntax.ssyntax_args_str
     (string_transform (fun hd tl => expansion.str `(syntax.cons ${hd} ${tl})`)
            [ captured (syntax syntax_syntax.makam_ident),
              captured syntax_syntax.ssyntax_args_str ]).
rule syntax_syntax.ssyntax_args_str
     (string_transform (eq "syntax.nil") []).

%end.

%extend pretty.

rule syntax_syntax.ssyntax
     (unapply syntax.apply
      [ captured syntax_syntax.makam_term, syntax (syntax.token "{"), captured syntax_syntax.ssyntax_args, syntax (syntax.token "}") ]).
rule syntax_syntax.ssyntax_args
     (unapply (fun hd tl => syntax.cons (syntax.captured hd) tl)
       [ syntax (syntax.token "["),
         captured syntax_syntax.makam_term,
         syntax (syntax.token "]"),
         captured syntax_syntax.ssyntax_args ]).
rule syntax_syntax.ssyntax_args
     (unapply (fun hd tl => syntax.cons (syntax.token hd) tl)
       [ captured (syntax syntax_syntax.string_literal),
         captured syntax_syntax.ssyntax_args ]).
rule syntax_syntax.ssyntax_args
     (unapply (syntax.cons : syntax unit -> syntax.syntax_args B C -> syntax.syntax_args B C)
       [ captured syntax_syntax.makam_term,
         captured syntax_syntax.ssyntax_args ]).
rule syntax_syntax.ssyntax_args
     (unapply syntax.nil []).

rule syntax_syntax.makam_term
     (untransform (pfun res str => refl.headname str res)
       [ captured (syntax syntax_syntax.makam_ident) ]).

%end.

%extend syntax.

topssyntax: syntax dyn.
isossyntax: syntax string.
isossyntax_args: syntax string.
stringtransform : (string -> string -> expansion) -> syntax_args (string -> string -> expansion) expansion -> syntax string.

rule_iso (stringtransform E Args)
         (peg.string_transform (pfun a b => expansion.str (E a b)) PegArgs)
         (pretty.untransform (pfun a b (res: string) => eqv (E a b) `${res}`) PrettyArgs) :-
  cast_args Args Args',
  to_peg_args Args' PegArgs,
  to_pretty_args Args' PrettyArgs.

rule isossyntax
          (stringtransform (fun id args => `syntax.apply ${id} ${args}`)
          [ captured syntax_syntax.makam_ident, token "{", captured isossyntax_args, token "}" ]).
rule isossyntax_args
     (stringtransform (fun hd tl => `(syntax.cons (syntax.captured ${hd}) ${tl})`)
            [ token "[",
              captured syntax_syntax.makam_ident,
              token "]",
              captured isossyntax_args ]).
rule isossyntax_args
     (stringtransform (fun hd tl => `(syntax.cons (syntax.token "${hd}") ${tl})`)
            [ captured syntax_syntax.string_literal,
              captured isossyntax_args ]).
rule isossyntax_args
     (stringtransform (fun hd tl => `(syntax.cons ${hd} ${tl})`)
            [ captured syntax_syntax.makam_ident,
              captured isossyntax_args ]).
rule isossyntax_args
     (apply "syntax.nil" []).

inline topssyntax.
rule topssyntax (transform (pfun a res => [X] refl.fromstring a X, eq res (dyn X))
                "function (x) { return `dyn (${JSON.parse(x)})`; }"
                (pfun res x => [Y] eq x (dyn Y), tostring_qualified Y res) [ captured isossyntax ]).
%end.

ssyntax : syntax (syntax A).
ssyntax_args : syntax (syntax.syntax_args A B).

(* since the syntactic rules are the same across all types,
   we "hide" the type information so that we can generate a single
   JS parser for syntax, and use it for all types.
*)
ssyntax_dyn : syntax dyn.
ssyntax_args_dyn : syntax dyn.

%extend syntax.

rule_iso ssyntax
         (peg.transform refl.fromstring "function(x) { return JSON.parse(x); }" (peg.cons (peg.captured syntax_syntax.ssyntax_str) peg.nil))
         (syntax_syntax.ssyntax).

rule_iso ssyntax_args
         (peg.transform refl.fromstring "function(x) { return JSON.parse(x); }" (peg.cons (peg.captured syntax_syntax.ssyntax_args_str) peg.nil))
         (syntax_syntax.ssyntax_args).

rule ssyntax_dyn (apply dyn [ captured ssyntax ]).
rule ssyntax_args_dyn (apply dyn [ captured ssyntax_args ]).
%end.

`( syntax.def_js ssyntax_args_dyn ).

%extend syntax.

new_rule : [A B] syntax A -> B -> string -> cmd -> prop.
new_rule Syntax Constructor Args_S
         (cmd_newclause (clause
           (syntax.rule Syntax (syntax.apply Constructor Args))
           success)) :-
  if (parse_opt ssyntax_args_dyn Args_S (dyn Args_Untyped))
  then
    (if (dyn.eq Args_Untyped Args)
     then success
     else (if (refl.typstring Args_Untyped TypArgsS')
           then expansion.str `(${TypArgsS'}) ` TypArgsS
           else eq TypArgsS "",
           if (refl.typstring Args TypConstrS')
           then expansion.str `(${TypConstrS'}) ` TypConstrS
           else eq TypConstrS "",
           log_error Args_S `type of syntax arguments ${TypArgsS}does not match type of constructor${TypConstrS}`, failure))
  else (log_error Args_S `parsing the syntax rule failed`, failure).

%end.

%extend syntax_syntax.

term : type.
term : syntax term.

lam : string -> term -> term.
app : term -> term -> term.
var : string -> term.

tests : testsuite. %testsuite tests.

(* TODO: make tostring/fromstring more robust for cases like below. *)

(syntax.parse_opt syntax.topssyntax "syntax_syntax.lam { 'λ' [syntax_syntax.ident] '.' [syntax_syntax.term] }" X,
 syntax.pretty syntax.topssyntax X Y ) ?

>> syntax.parse_opt ssyntax_dyn "syntax_syntax.lam { 'λ' [syntax_syntax.ident] '.' [syntax_syntax.term] }" (dyn X) ?
>> Yes:
>> X := (syntax.apply lam (syntax.cons (syntax.token "λ") (syntax.cons (syntax.captured ident) (syntax.cons (syntax.token ".") (syntax.cons (syntax.captured term) syntax.nil))))).

>> syntax.pretty ssyntax (syntax.apply lam (syntax.cons (syntax.token "λ") (syntax.cons (syntax.captured ident) (syntax.cons (syntax.token ".") (syntax.cons (syntax.captured term) syntax.nil))))) X ?
>> Yes:
>> X := " syntax_syntax.lam { 'λ' [ syntax_syntax.ident ] '.' [ syntax_syntax.term ] }".

`( syntax.new_rule term lam "'λ' [ident] '.' [term]" ).
`( syntax.new_rule term var "[ident]" ).
`( syntax.new_rule term app "'(' [term] [term] ')'" ).

`( syntax.def_js term ).

>> syntax.parse_opt term "λx.λy.((y x) x)" X ?
>> Yes:
>> X := lam "x" (lam "y" (app (app (var "y") (var "x")) (var "x"))).

>> syntax.pretty term (lam "x" (lam "y" (app (app (var "y") (var "x")) (var "x")))) X ?
>> Yes:
>> X := " λ x . λ y . ( ( y x ) x )".

%end.
