constructor_definitions : string -> cmd -> prop.

%open syntax.
%open peg.
%open syntax_syntax.

%extend constructor_syntax.

constructor_def : type.
constructor_def : string -> list string -> string -> constructor_def.

create_type_string : list string -> string -> string -> prop.
create_type_string [] Target Target.
create_type_string (HDType :: TL) Target Result :-
  create_type_string TL Target Result',
  expansion.str `${HDType} -> ${Result'}` Result.

to_type : constructor_def -> Type -> prop.
to_type (constructor_def _ Args Target) Type :-
  create_type_string Args Target TypeString,
  expansion.str `(_: ${TypeString})` FullString,
  refl.fromstring FullString Type.

to_cmd : constructor_def -> cmd -> prop.
to_cmd Def (cmd_newterm Name Type) when eq Def (constructor_def Name _ _) :-
  to_type Def Type.

s_constructor_defs : syntax (list constructor_def).
s_constructor_def : syntax constructor_def.
constructor_arg : syntax string.
typ : syntax string.
param_name : syntax unit.

`( syntax_rules {{

typ -> { <iso makam.typ_str (pretty.syntax (charmany anychar))> }

s_constructor_def ->
  constructor_def { <makam.ident> <many constructor_arg> ":" <typ> "." }

constructor_arg -> { "(" param_name ":" <typ> ")" }

param_name -> { <iso (ignore (syntax makam.unifident)) (pretty.const "_")> }

}}).

`( syntax.def_js s_constructor_defs (once_or_many s_constructor_def) ).

constructor_definitions S (cmd_many Cmds) :-
  syntax.parse_opt s_constructor_defs S Defs, map to_cmd Defs Cmds.

hello : type.

`( constructor_definitions {{

kalimera (H: hello) (S: string) (Q : list Q) (E : list Q) : hello.

}}).

%type kalimera.

syntax.pretty s_constructor_def (constructor_def "lala" ["list Q"] "list Q") X ?

%end.

