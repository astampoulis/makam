%extend syntax.

group : syntax_args (A -> A) A -> syntax A.
inline (group _).
rule (group PS) (apply (fun x => x) PS).

once_or_many : syntax A -> syntax (list A).
inline (once_or_many _).
rule (once_or_many P) (apply cons [ captured P, captured (many P) ]).

option : syntax A -> syntax (option A).
inline (option _).
rule (option P) (apply some [captured P]).
rule (option P) (apply none []).

optunit : syntax unit -> syntax unit.
inline (optunit _).
rule (optunit P) (apply unit [choices [P, empty]]).

list_sep : syntax unit -> syntax A -> syntax (list A).
list_sep_plus : syntax unit -> syntax A -> syntax (list A).

rule (list_sep_plus Sep P) (apply cons [captured P, Sep, captured (list_sep_plus Sep P)]).
rule (list_sep_plus Sep P) (apply cons [captured P, captured (apply nil [])]).
rule (list_sep Sep P) (list_sep_plus Sep P).
rule (list_sep Sep P) (apply nil []).

charmany : syntax string -> syntax string.
rule (charmany P) (transform (pfun hd_tl res => [HD TL] eq hd_tl [HD, TL], string.append HD TL res)
                             "(a, b) => JSON.stringify(JSON.parse(a) + JSON.parse(b))"
                             (pfun str res => [HD TL] string.headtail str HD TL,
                                                      eq res [HD, TL])
                             [ captured P, captured (charmany P) ]).
rule (charmany P) (apply "" []).

char_once_or_many : syntax string -> syntax string.
inline (char_once_or_many _).
rule (char_once_or_many P)
     (transform (pfun hd_tl res => [HD TL] eq hd_tl [HD, TL], string.append HD TL res)
                "(a, b) => JSON.stringify(JSON.parse(a) + JSON.parse(b))"
                (pfun str res => [HD TL] string.headtail str HD TL,
                                 eq res [HD, TL])
                [ captured P, captured (charmany P) ]).

(* whitespace is not completely isomorphic between parsing and pretty-printing.
   when parsing, we just ignore whitespace.
   for printing, we need to specify what kind of whitespace to add. this will
   be done with actual pretty-printing in the future, but for now, we just
   specify whether we print nothing, a single space, or a newline by default.
*)
ws_empty : syntax unit. inline (ws_empty).
ws_space : syntax unit. inline (ws_space).
ws_newline : syntax unit. inline (ws_newline).

rule_iso ws_empty peg.ws pretty.empty.
rule_iso ws_space peg.ws (pretty.const " ").
rule_iso ws_newline peg.ws (pretty.const "\n").
%end.

ident : syntax string.

%extend syntax.

rule ident (group [optunit ws_space, captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz")), optunit ws_empty ]).

untyped : A -> B.

syn : syntax (syntax A).
syn_args : syntax (syntax_args A B).
makam_ident : syntax A.
captured_makam_ident : pretty.pretty (syntax.syntax_captured A).
ignored_makam_ident : pretty.pretty (syntax A).

token : string -> syntax unit.
rule (token S) (apply unit [ optunit ws_space, exact S, optunit ws_empty ]).

rule_iso syn (peg.syntax (apply .syntax.apply
          [ captured makam_ident, token "{", captured syn_args, token "}" ]))
          (pretty.syntax (apply .syntax.apply
          [ captured ident, token "{", captured syn_args, token "}" ])).
rule_iso syn_args
     (peg.syntax (apply (fun hd tl => untyped (.syntax.cons (.syntax.captured hd) tl))
            [ token "[",
              captured makam_ident,
              token "]",
              captured syn_args ]))
    (pretty.unapply syntax.cons
            (pretty.cons (pretty.syntax (token "["))
            (pretty.cons (pretty.captured captured_makam_ident)
            (pretty.cons (pretty.syntax (token "]"))
            (pretty.cons (pretty.captured (pretty.syntax syn_args)) pretty.nil))))).
rule_iso syn_args
     (peg.syntax (apply .syntax.cons
            [ captured makam_ident,
              captured syn_args ]))
     (pretty.unapply (.syntax.cons: syntax A -> syntax_args B C -> syntax_args B C)
            (pretty.cons (pretty.captured ignored_makam_ident)
            (pretty.cons (pretty.captured (pretty.syntax syn_args))
            (pretty.nil)))).
rule_iso syn_args
     (peg.syntax (apply .syntax.nil []))
     (pretty.syntax (apply .syntax.nil [])).

rule makam_ident
     (transform (pfun hd res => [HD] eq hd [HD], fromstring HD res)
                "function (x) { return JSON.parse(x); }"
                (pfun str res => [HD] eq res [HD], refl.headname str HD)
      [ captured ident ]).

pretty.builtin captured_makam_ident.
pretty.pretty captured_makam_ident (captured X) (some Res) :-
  refl.headname X Str,
  expansion.str `(syntax.captured ${Str})` Res.

pretty.builtin ignored_makam_ident.
pretty.pretty ignored_makam_ident X (some Res) :-
  refl.headname X Res.

expand : [B]B -> C -> prop.
expand_aux : [B]B -> C -> prop.

expand X Y :- demand.case_otherwise (expand_aux X Y)
                                    (structural expand X Y).
expand_aux (untyped X) Z when debugfull(print X), debugfull(print Z) :-
  expand X X', print X,
  if (debugfull(dyn.eq X' Z)) then print "yes" else print "no".

topsyn : syntax (syntax A).
rule topsyn (transform (pfun hd res => [HD] eq hd [ HD ], expand HD res) "" (pfun x y => success) [ captured syn ]).

%end.

tata : type.
lam : string -> string -> tata.

(eq syntax.syn Expr,
 eq "lam { [ident] [ident] }" Input,
 once(syntax.parse Expr Input ParseResult),
 debugfull(print ParseResult),
 syntax.expand ParseResult TataResult
 ) ?
