%extend syntax.

group : syntax_args (A -> A) A -> syntax A.
inline (group _).
rule (group PS) (apply (fun x => x) PS).

once_or_many : syntax A -> syntax (list A).
inline (once_or_many _).
rule (once_or_many P) (apply cons [ captured P, captured (many P) ]).

option : syntax A -> syntax (option A).
inline (option _).
rule (option P) (apply some [captured P]).
rule (option P) (apply none []).

optunit : syntax unit -> syntax unit.
inline (optunit _).
rule (optunit P) (apply unit [choices [P, empty]]).

list_sep : syntax unit -> syntax A -> syntax (list A).
list_sep_plus : syntax unit -> syntax A -> syntax (list A).

rule (list_sep_plus Sep P) (apply cons [captured P, Sep, captured (list_sep_plus Sep P)]).
rule (list_sep_plus Sep P) (apply cons [captured P, captured (apply nil [])]).
rule (list_sep Sep P) (list_sep_plus Sep P).
rule (list_sep Sep P) (apply nil []).

charmany : syntax string -> syntax string.
rule (charmany P) (transform (pfun hd_tl res => [HD TL] eq hd_tl [HD, TL], string.append HD TL res)
                             "(a, b) => JSON.stringify(JSON.parse(a) + JSON.parse(b))"
                             (pfun str res => [HD TL] string.headtail str HD TL,
                                                      eq res [HD, TL])
                             [ captured P, captured (charmany P) ]).
rule (charmany P) (apply "" []).

char_once_or_many : syntax string -> syntax string.
inline (char_once_or_many _).
rule (char_once_or_many P)
     (transform (pfun hd_tl res => [HD TL] eq hd_tl [HD, TL], string.append HD TL res)
                "(a, b) => JSON.stringify(JSON.parse(a) + JSON.parse(b))"
                (pfun str res => [HD TL] string.headtail str HD TL,
                                 eq res [HD, TL])
                [ captured P, captured (charmany P) ]).

(* whitespace is not completely isomorphic between parsing and pretty-printing.
   when parsing, we just ignore whitespace.
   for printing, we need to specify what kind of whitespace to add. this will
   be done with actual pretty-printing in the future, but for now, we just
   specify whether we print nothing, a single space, or a newline by default.
*)
ws_empty : syntax unit. inline (ws_empty).
ws_space : syntax unit. inline (ws_space).
ws_newline : syntax unit. inline (ws_newline).

rule_iso ws_empty peg.ws pretty.empty.
rule_iso ws_space peg.ws (pretty.const " ").
rule_iso ws_newline peg.ws (pretty.const "\n").
%end.

ident : syntax string.

%extend syntax.

rule ident (group [optunit ws_space, captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz")), optunit ws_empty ]).

untyped : A -> B.
deferred : (A -> prop) -> A.

syn : syntax (syntax A).
syn_args : syntax (syntax_args A B).
makam_ident : syntax A.

token : string -> syntax unit.
rule (token S) (apply unit [ optunit ws_space, exact S, optunit ws_empty ]).

rule_iso syn (peg.syntax (apply .syntax.apply
          [ captured ident, token "{", captured syn_args, token "}" ]))
          (pretty.syntax (apply .syntax.apply
          [ captured ident, token "{", captured syn_args, token "}" ])).
rule_iso syn_args
     (peg.syntax (apply (fun hd tl => untyped (.syntax.cons (.syntax.captured hd) tl))
            [ token "[",
              captured makam_ident,
              token "]",
              captured syn_args ]))
    (pretty.syntax (apply (fun hd tl => untyped (.syntax.cons (.syntax.captured hd) tl))
            [ token "[",
              captured makam_ident,
              token "]",
              captured syn_args ])).
rule_iso syn_args
     (peg.syntax (apply .syntax.cons
            [ captured makam_ident,
              captured syn_args ]))
     (pretty.syntax (apply .syntax.cons
            [ captured makam_ident,
              captured syn_args ])).
rule_iso syn_args
     (peg.syntax (transform (pfun non res => eq res .syntax.nil) "" (pfun a c => success) []))
     (pretty.syntax (transform (pfun non res => eq res .syntax.nil) "" (pfun a c => success) [])).

rule makam_ident (apply (fun s => deferred (fromstring s)) [ captured ident ]).

%end.

tata : type.
lam : string -> string -> tata.

(eq syntax.syn Expr,
 eq "lam { [ident] [ident] }" Input,
 syntax.parse Expr Input ParseResult
 ) ?
