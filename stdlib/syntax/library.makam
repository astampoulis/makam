%extend syntax.

group : syntax_args (A -> A) A -> syntax A.
inline (group _).
rule (group PS) (apply (fun x => x) PS).

once_or_many : syntax A -> syntax (list A).
inline (once_or_many _).
rule (once_or_many P) (apply cons [ captured P, captured (many P) ]).

option : syntax A -> syntax (option A).
inline (option _).
rule (option P) (apply some [captured P]).
rule (option P) (apply none []).

optunit : syntax unit -> syntax unit.
inline (optunit _).
rule (optunit P) (apply unit [choices [P, empty]]).

list_sep : syntax unit -> syntax A -> syntax (list A).
list_sep_plus : syntax unit -> syntax A -> syntax (list A).

rule (list_sep_plus Sep P) (apply cons [captured P, Sep, captured (list_sep_plus Sep P)]).
rule (list_sep_plus Sep P) (apply cons [captured P, captured (apply nil [])]).
rule (list_sep Sep P) (list_sep_plus Sep P).
rule (list_sep Sep P) (apply nil []).

charmany : syntax string -> syntax string.
rule (charmany P) (transform (pfun hd_tl res => [HD TL] eq hd_tl [HD, TL], string.append HD TL res)
                             "(a, b) => JSON.stringify(JSON.parse(a) + JSON.parse(b))"
                             (pfun str res => [HD TL] string.headtail str HD TL,
                                                      eq res [HD, TL])
                             [ captured P, captured (charmany P) ]).
rule (charmany P) (apply "" []).

char_once_or_many : syntax string -> syntax string.
inline (char_once_or_many _).
rule (char_once_or_many P)
     (transform (pfun hd_tl res => [HD TL] eq hd_tl [HD, TL], string.append HD TL res)
                "(a, b) => JSON.stringify(JSON.parse(a) + JSON.parse(b))"
                (pfun str res => [HD TL] string.headtail str HD TL,
                                 eq res [HD, TL])
                [ captured P, captured (charmany P) ]).

(* whitespace is not completely isomorphic between parsing and pretty-printing.
   when parsing, we just ignore whitespace.
   for printing, we need to specify what kind of whitespace to add. this will
   be done with actual pretty-printing in the future, but for now, we just
   specify whether we print nothing, a single space, or a newline by default.
*)
ws_empty : syntax unit. inline (ws_empty).
ws_space : syntax unit. inline (ws_space).
ws_newline : syntax unit. inline (ws_newline).

rule_iso ws_empty peg.ws pretty.empty.
rule_iso ws_space peg.ws (pretty.const " ").
rule_iso ws_newline peg.ws (pretty.const "\n").
%end.

ident : syntax string.

%extend syntax.

rule ident (group [optunit ws_space, captured (char_once_or_many (charclass "abcdefghijklmnopqrstuvwxyz")), optunit ws_empty ]).

syn : syntax (syntax A).
syn_args : syntax (syntax_args A B).
makam_ident : syntax A.

token : string -> syntax unit.
inline (token _).
rule (token S) (apply unit [ optunit ws_space, exact S, optunit ws_empty ]).

untyped : A -> B.

rule_iso syn (peg.syntax (apply syntax.apply
          [ captured makam_ident, token "{", captured syn_args, token "}" ]))
          (pretty.syntax (apply .syntax.apply
          [ captured makam_ident, token "{", captured syn_args, token "}" ])).
rule_iso syn_args
     (peg.syntax (apply (fun hd tl => untyped (.syntax.cons (.syntax.captured hd) tl))
            [ token "[",
              captured makam_ident,
              token "]",
              captured syn_args ]))
    (pretty.unapply (fun hd tl => syntax.cons (syntax.captured hd) tl)
            (pretty.cons (pretty.syntax (token "["))
            (pretty.cons (pretty.captured (pretty.syntax makam_ident))
            (pretty.cons (pretty.syntax (token "]"))
            (pretty.cons (pretty.captured (pretty.syntax syn_args)) pretty.nil))))).
rule_iso syn_args
     (peg.syntax (apply .syntax.cons
            [ captured makam_ident,
              captured syn_args ]))
     (pretty.unapply (.syntax.cons: syntax A -> syntax_args B C -> syntax_args B C)
            (pretty.cons (pretty.captured (pretty.syntax makam_ident))
            (pretty.cons (pretty.captured (pretty.syntax syn_args))
            (pretty.nil)))).
rule_iso (syn_args: syntax (syntax_args A A))
     (peg.syntax (apply (.syntax.nil: (syntax_args A A)) []))
     (pretty.syntax (apply .syntax.nil [])).

rule makam_ident
     (transform (pfun hd res => [HD] eq hd [HD], fromstring HD res)
                "function (x) { return JSON.parse(x); }"
                (pfun str res => [HD] eq res [HD], refl.headname str HD)
      [ captured ident ]).

remove_untyped : [B]B -> C -> prop.
remove_untyped_aux : [B C]B -> C -> prop.

remove_untyped X Y :- demand.case_otherwise (remove_untyped_aux X Y)
                                    (structural_dyntyped remove_untyped X Y).

remove_untyped_aux (untyped X) X' :-
  remove_untyped X X'.

topsyn : syntax (syntax A).
rule topsyn (transform (pfun hd res => [HD] eq hd [ HD ], remove_untyped HD res)
                       "function (x) { console.error(x); return x; }"
                       (pfun x y => eq y [x])
                       [ captured syn ]).

dynsyn : syntax dyn.
rule dynsyn (transform (pfun hd res => [HD Res] eq hd [ HD ], remove_untyped HD Res, eq res (dyn Res))
                       "function (x) { console.error(x); return x; }"
                       (pfun x y => [R] eq x (dyn R), eq y [R])
                       [ captured syn ]).

%end.

tata : type.
lam : string -> tata.

(eq syntax.syn Expr,
 eq "lam { [ident] }" Input,
 once(syntax.parse Expr Input ParseResult),
 print ParseResult,
 once(syntax.parse_opt Expr Input ParseResult2),
 print ParseResult2,
 once(syntax.pretty syntax.syn (syntax.apply lam (syntax.cons (syntax.captured ident) syntax.nil)) X), print_string `Pretty: {{${X}}}\n`,
 syntax.remove_untyped ParseResult TataResult,
 syntax.parse TataResult "hello" FinalResult
 ) ?


%extend peg.
str_expand : (string -> string -> expansion) -> peg_args (string -> string -> string) string -> peg string.
inline (str_expand _ _).
rule (str_expand S_E PS)
     (transform (pfun a_b res => [A B S] eq a_b [A, B], expansion.str (S_E A B) res)
                Code
                PS) :-
  expansion.str (S_E "${res_a}" "${res_b}") E_Code,
  expansion.str `function (a, b) { const res_a = JSON.parse(a); const res_b = JSON.parse(b); return JSON.stringify(\`${E_Code}\`); }` Code.

ssyn : peg string.
ssyn_args : peg string.

rule ssyn (str_expand (fun id args => `(syntax.apply ${id} ${args})`)
          [ captured (peg.syntax ident), (peg.syntax (syntax.token "{")), captured ssyn_args, (peg.syntax (syntax.token "}")) ]).
rule ssyn_args
     (str_expand (fun hd tl => `(syntax.cons (syntax.captured ${hd}) ${tl})`)
            [ peg.syntax (syntax.token "["),
              captured (peg.syntax ident),
              peg.syntax (syntax.token "]"),
              captured ssyn_args ]).
rule ssyn_args
     (str_expand (fun hd tl => `(syntax.cons ${hd} ${tl})`)
            [ captured (peg.syntax ident),
              captured ssyn_args ]).
rule ssyn_args
     (apply "syntax.nil" []).

%end.

(eq peg.ssyn Expr,
 eq "lam { [ident] }" Input,
 peg.parse_opt Expr Input (ParseResult, ""),
 peg.parse Expr Input (ParseResult2, ""),
 fromstring ParseResult TataResult) ?

