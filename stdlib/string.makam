%extend string.

concat : list string -> string -> prop.

concat_backwards : list string -> list string -> list string -> prop.

concat_backwards [] [] [].

concat_backwards Consume (X :: Rest) Consume'' when refl.isunif X :-
  prefix Prefix Consume Consume',
  string.explode X Prefix,
  concat_backwards Consume' Rest Consume''.

concat_backwards Consume (S :: Rest) Consume'' when refl.isconst S :-
  string.explode S SL,
  append SL Consume' Consume,
  concat_backwards Consume' Rest Consume''.

concat Strings Result <-
  if (refl.isunif Result) then
    foldl append "" Strings Result
  else (
    string.explode Result ResultL,
    concat_backwards ResultL Strings []
  ).

%end.

%extend builtin.
print_string : string -> prop.
print_string X :- .print_string X.
%end.

show, show_def : [A]A -> string -> prop.
show X S :- if (show_def X S) then success else (tostring X S).

show_def (X: string) X.

print_string : [A]A -> prop.
print_string (S : string) :- builtin.print_string S.


expansion : type.
expansion : list string -> expansion.

%extend expansion.
isconcrete : expansion -> prop.
isconcrete E when not(refl.isunif E), eq E (expansion L), not(refl.isunif L) :-
  map (pfun s => not(refl.isunif s)) L.
%end.

without_eqv_refl (_ : expansion).

eqv (expansion A) (expansion B) when expansion.isconcrete (expansion A) :-
  string.concat A A',
  string.concat B A'.

eqv (expansion A) (expansion B) when not(expansion.isconcrete (expansion A)), expansion.isconcrete (expansion B) :-
  string.concat B B',
  string.concat A B'.

show_def (expansion X) S when expansion.isconcrete (expansion X) :-
  string.concat X S.

print_string (X : expansion) when show X S :- builtin.print_string S.
