concrete : type -> type.
concrete_args : type -> type -> type.

%extend concrete.

namespace : type.
apply : A -> concrete_args A B -> concrete B.
lambda : namespace -> string -> concrete B -> concrete (A -> B).
bindone : namespace -> string -> concrete B -> concrete (bindone A B).
var : namespace -> string -> concrete A.

nil : concrete_args A A.
cons : concrete A -> concrete_args B C -> concrete_args (A -> B) C.

resolve, resolve0, resolve0_applies, resolve1 : [A] concrete A -> A -> prop.
resolve_args : [A B] concrete_args A B -> args A B -> prop.
resolve_var : [A] namespace -> string -> A -> prop.

handle_unresolved_var : [A] namespace -> string -> A -> prop.

vars_in_context, vars_in_context_store : namespace -> list (dyn * string) -> prop.
vars_in_context_store Namespace [].
vars_in_context Namespace Vars :- once(vars_in_context_store Namespace Vars).

pick_var_prefix, pick_var_prefix_userdef : namespace -> string -> prop.
pick_var_prefix Namespace ID :-
  unless (pick_var_prefix_userdef Namespace ID)
         (eq ID "x").

pick_var_name, pick_var_name_userdef : namespace -> string -> prop.
pick_var_name Namespace ID :-
  unless (pick_var_name_userdef Namespace ID)
         {prop|
          vars_in_context Namespace Vars,
          length Vars L, tostring L L_S,
          pick_var_prefix Namespace Prefix,
          expansion.str `${Prefix}${L_S}` ID |}.

namespace_for_variable : [Type] Type -> namespace -> prop.
pick_namespace : [Type] Type -> namespace -> prop.

pick_namespace _ Namespace when not(refl.isunif Namespace).
pick_namespace Var Namespace when refl.isunif Namespace :-
  namespace_for_variable Var Namespace.

resolve X Y :- if (resolve0_applies X Y) then resolve0 X Y else resolve1 X Y.

resolve0_applies (lambda _ _ _) (F : A -> B).
resolve0 (lambda Namespace ID Body) (F: A -> B) :-
  (x:A ->
   resolve_var Namespace ID x ->
   (pick_namespace x Namespace,
    vars_in_context Namespace Vars,
    (vars_in_context_store Namespace ((dyn x, ID) :: Vars) ->
      (if (refl.isunif ID) then pick_var_name Namespace ID else success,
       resolve Body (F x))))).

resolve0_applies (bindone _ _ _) (bindone _ _).
resolve0 (bindone Namespace ID Body) (bindone ID Body') :-
  resolve (lambda Namespace ID Body) Body'.

resolve0_applies (var _ _) X when refl.isunif X.
resolve0_applies (var Namespace ID) X when not(refl.isunif X), pick_namespace X Namespace, either (resolve_var Namespace ID X) (handle_unresolved_var Namespace ID X).
resolve0 (var Namespace ID) X :-
 pick_namespace X Namespace,
 if (once(resolve_var Namespace ID X))
 then success
 else handle_unresolved_var Namespace ID X.

resolve1 (apply F Args) Result when refl.isunif Result :-
  resolve_args Args Args',
  args.apply F Args' Result.

resolve1 X Result when not(refl.isunif Result) :-
  refl.headargs Result Head ArgsDyn,
  dyn.to_args ArgsDyn Args,
  resolve_args ArgsConcrete Args,
  dyn.eq X (concrete.apply Head ArgsConcrete).

resolve_args nil nil.
resolve_args (cons HD TL) (cons HD' TL') :-
  resolve HD HD', resolve_args TL TL'.

%end.
