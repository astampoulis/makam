args : type -> type -> type.
nil : args A A.
cons : A -> args B C -> args (A -> B) C.

%extend args.
apply : [A] A -> args A B -> B -> prop.
apply X [] X.
apply X (HD :: TL) X' :- apply (X HD) TL X'.

(* Apply all arguments, saturating the given function.

   When the argument list is not specified, this will repeatedly apply
   arguments, generating new unification variables, for the full arity
   of the functional argument. *)

applyfull : [A] A -> args A B -> B -> prop.
applyfull (X: A -> B) (HD :: TL) Res :- applyfull (X HD) TL Res.
applyfull X [] X when not(typ.eq X (_ : A -> B)).
%end.

%extend dyn.
to_args : [A B] list dyn -> args A B -> prop.
to_args [] [].
to_args (dyn HD :: TL) (HD :: TL') :- to_args TL TL'.

from_args : [A B] args A B -> list dyn -> prop.
from_args [] [].
from_args (HD :: TL) (dyn HD :: TL') :- from_args TL TL'.
%end.
